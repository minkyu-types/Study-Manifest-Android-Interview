## Q) 45. ì•ˆë“œë¡œì´ë“œì˜ Bitmapì´ë€ ë¬´ì—‡ì´ë©°, í° Bitmapì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì€ ë¬´ì—‡ì¸ê°€ìš”?

- Bitmapì€ ë©”ëª¨ë¦¬ ë‚´ ì´ë¯¸ì§€ í‘œí˜„ìœ¼ë¡œ, í”½ì…€ ë°ì´í„°ë¥¼ ì €ì¥í•˜ë©° ë¦¬ì†ŒìŠ¤, íŒŒì¼, ì›ê²© ì†ŒìŠ¤ì—ì„œ ê°€ì ¸ì˜¨ ì´ë¯¸ì§€ë¥¼ í™”ë©´ì— ë Œë”ë§í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
- ê³ í•´ìƒë„ ì´ë¯¸ì§€ë¥¼ ë¶€ì ì ˆí•˜ê²Œ ì²˜ë¦¬í•˜ë©´ OutOfMemoryError ë“± ë©”ëª¨ë¦¬ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### í° Bitmapì˜ ë¬¸ì œì 

- ì¹´ë©”ë¼ë‚˜ ì¸í„°ë„·ì—ì„œ ë°›ì€ ì´ë¯¸ì§€ëŠ” UIê°€ ìš”êµ¬í•˜ëŠ” í¬ê¸°ë³´ë‹¤ í° ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤.
- ì „ì²´ í•´ìƒë„ë¡œ ë¡œë“œí•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œ ë°œìƒ:
  * ê³¼ë„í•œ ë©”ëª¨ë¦¬ ì†Œë¹„
  * ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ ìœ ë°œ
  * ë©”ëª¨ë¦¬ ì••ë°•ìœ¼ë¡œ ì¸í•œ í¬ë˜ì‹œ ë°œìƒ ìœ„í—˜

### ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•˜ì§€ ì•Šê³  Bitmap í¬ê¸° ì½ê¸°

- ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•˜ê¸° ì „ í¬ê¸°ë¥¼ í™•ì¸í•´ ë¶ˆí•„ìš”í•œ ë©”ëª¨ë¦¬ í• ë‹¹ì„ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- `BitmapFactory.Options`ì—ì„œ `inJustDecodeBounds = true`ë¡œ ì„¤ì •í•˜ë©´ í”½ì…€ ë°ì´í„°ë¥¼ í• ë‹¹í•˜ì§€ ì•Šê³  ë©”íƒ€ë°ì´í„°ë§Œ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```kotlin
val options = BitmapFactory.Options().apply {
    inJustDecodeBounds = true
}
BitmapFactory.decodeResource(resources, R.drawable.myimage, options) // R.id -> R.drawable ìˆ˜ì •

val imageWidth = options.outWidth
val imageHeight = options.outHeight
val imageType = options.outMimeType
```

### ìƒ˜í”Œë§ì„ ì‚¬ìš©í•˜ì—¬ ì¶•ì†Œëœ Bitmap ë¡œë“œí•˜ê¸°

* ì´ë¯¸ì§€ í¬ê¸°ë¥¼ ì•Œë©´ `inSampleSize`ë¡œ ë¹„íŠ¸ë§µì„ ëŒ€ìƒ í¬ê¸°ì— ë§ê²Œ ì¶•ì†Œ ê°€ëŠ¥
* 2, 4 ë“±ì˜ ë°°ìˆ˜ë¡œ ì„œë¸Œìƒ˜í”Œë§í•´ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì ˆê°
* ì˜ˆ: `inSampleSize = 4` â†’ 2048Ã—1536 ì´ë¯¸ì§€ë¥¼ 512Ã—384ë¡œ ì¶•ì†Œ

```kotlin
fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {
    // ì´ë¯¸ì§€ì˜ ì›ë³¸ ë†’ì´ì™€ ë„ˆë¹„
    val (height, width) = options.run { outHeight to outWidth }
    var inSampleSize = 1

    if (height > reqHeight || width > reqWidth) {
        val halfHeight = height / 2
        val halfWidth = width / 2

        // ìš”ì²­ëœ ë„ˆë¹„ì™€ ë†’ì´ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì„ ë•Œê¹Œì§€ inSampleSizeë¥¼ 2ë°°ì”© ëŠ˜ë¦½ë‹ˆë‹¤.
        while (halfHeight / inSampleSize >= reqHeight && halfWidth / inSampleSize >= reqWidth) {
            inSampleSize *= 2
        }
    }
    return inSampleSize
}
```

### ì„œë¸Œìƒ˜í”Œë§ì„ ì‚¬ìš©í•œ ì „ì²´ ë””ì½”ë”© í”„ë¡œì„¸ìŠ¤

* calculateInSampleSizeë¥¼ ì‚¬ìš©í•˜ì—¬ ë‘ ë‹¨ê³„ë¡œ ë¹„íŠ¸ë§µ ë””ì½”ë”©:

    1. ê²½ê³„ë§Œ ë””ì½”ë”©í•´ í¬ê¸° í™•ì¸
    2. ê³„ì‚°ëœ `inSampleSize`ë¡œ ì¶•ì†Œëœ ë¹„íŠ¸ë§µ ë””ì½”ë”©

* UIì— ì ì ˆí•œ í¬ê¸°ì˜ ì´ë¯¸ì§€ë¥¼ ìµœì  ë©”ëª¨ë¦¬ë¡œ ì œê³µ

```kotlin
fun decodeSampledBitmapFromResource(
    res: Resources,
    resId: Int,
    reqWidth: Int,
    reqHeight: Int
): Bitmap? { // Bitmap? ë°˜í™˜ íƒ€ì… ë³€ê²½ (ë””ì½”ë”© ì‹¤íŒ¨ ê°€ëŠ¥ì„±)
    // ë¨¼ì € inJustDecodeBounds=trueë¡œ í¬ê¸° í™•ì¸
    return BitmapFactory.Options().run {
        inJustDecodeBounds = true
        BitmapFactory.decodeResource(res, resId, this)

        // inSampleSize ê³„ì‚°
        inSampleSize = calculateInSampleSize(this, reqWidth, reqHeight)

        // inSampleSizeë¥¼ ì„¤ì •í•˜ê³  ë¹„íŠ¸ë§µ ë””ì½”ë”©
        inJustDecodeBounds = false
        BitmapFactory.decodeResource(res, resId, this)
    }
}
```

* ImageViewì— ì ìš© ì‹œ ê°„ë‹¨íˆ í˜¸ì¶œ:

```kotlin
// ImageView í¬ê¸°ì— ë§ê²Œ reqWidth, reqHeight ì„¤ì •
val bitmap = decodeSampledBitmapFromResource(resources, R.drawable.myimage, 100, 100)
imageView.setImageBitmap(bitmap)
```

### ğŸ’¡ Pro Tips for Mastery: ì»¤ìŠ¤í…€ ì´ë¯¸ì§€ ë¡œë”© ì‹œìŠ¤í…œì—ì„œ í° ë¹„íŠ¸ë§µ ìºì‹±ì„ ì–´ë–»ê²Œ êµ¬í˜„í•˜ë‚˜ìš”?

* ì´ë¯¸ì§€ ëª©ë¡, ê·¸ë¦¬ë“œ, ìºëŸ¬ì…€ ë“±ì—ì„œ í° ë¹„íŠ¸ë§µì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•´ ì›í™œí•˜ê³  ë©”ëª¨ë¦¬ ì•ˆì „í•œ ì•± êµ¬ì¶• í•„ìš”
* ì•ˆë“œë¡œì´ë“œëŠ” **LruCache(ë©”ëª¨ë¦¬ ìºì‹±)**, **[DiskLruCache(ë””ìŠ¤í¬ ìºì‹±)](https://github.com/JakeWharton/DiskLruCache)** ë‘ ê°€ì§€ ì „ëµ ì œê³µ

#### LruCacheë¥¼ ì‚¬ìš©í•œ ë©”ëª¨ë¦¬ ë‚´ ìºì‹±

LruCacheëŠ” ìµœê·¼ ì‚¬ìš© í•­ëª©ì— ëŒ€í•œ ê°•ë ¥í•œ ì°¸ì¡°ë¥¼ ìœ ì§€í•˜ê³ , ë©”ëª¨ë¦¬ ë¶€ì¡± ì‹œ ì˜¤ë˜ ì‚¬ìš©ë˜ì§€ ì•Šì€ í•­ëª© ìë™ ì œê±°í•©ë‹ˆë‹¤.
ì‘ë™ ë°©ì‹ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```kotlin
object LruCacheManager {
    // ì‚¬ìš© ê°€ëŠ¥í•œ ìµœëŒ€ ë©”ëª¨ë¦¬ (KB)
    val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
    // ìºì‹œ í¬ê¸°ë¥¼ ìµœëŒ€ ë©”ëª¨ë¦¬ì˜ 1/8ë¡œ ì„¤ì •
    val cacheSize = maxMemory / 8

    val memoryCache = object : LruCache<String, Bitmap>(cacheSize) {
        // ìºì‹œ í•­ëª© í¬ê¸°ë¥¼ KB ë‹¨ìœ„ë¡œ ì •ì˜
        override fun sizeOf(key: String, bitmap: Bitmap): Int {
            // ë¹„íŠ¸ë§µì˜ ë°”ì´íŠ¸ ìˆ˜ë¥¼ KBë¡œ ë³€í™˜
            return bitmap.byteCount / 1024
        }
    }
}

```

ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ì˜ 1/8 ì •ë„ë¥¼ ìºì‹œ í¬ê¸°ë¡œ í• ë‹¹í•´ ë©”ëª¨ë¦¬ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€ ë° ì¤‘ë³µ ë””ì½”ë”© íšŒí”¼í•©ë‹ˆë‹¤. ì‚¬ìš© ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```kotlin
fun loadBitmap(imageId: Int, imageView: ImageView) {
    val key = imageId.toString()
    // ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ ë¨¼ì € í™•ì¸
    LruCacheManager.memoryCache.get(key)?.let {
        imageView.setImageBitmap(it)
    } ?: run {
        // ìºì‹œì— ì—†ìœ¼ë©´ í”Œë ˆì´ìŠ¤í™€ë” ì„¤ì • ë° ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ìš”ì²­
        imageView.setImageResource(R.drawable.image_placeholder)

        val workRequest = OneTimeWorkRequestBuilder<BitmapDecodeWorker>()
            .setInputData(workDataOf("imageId" to imageId))
            .build()
        WorkManager.getInstance(context).enqueue(workRequest)
    }
}

```

ê·¸ë¦¬ê³  Jetpackì˜ ì»¤ìŠ¤í…€ Workerì—ì„œëŠ” ì•„ë˜ì™€ ê°™ì´ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```kotlin
class BitmapDecodeWorker(
    context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {

    override suspend fun doWork(): Result {
        val imageId = inputData.getInt("imageId", -1)
        if (imageId == -1) return Result.failure()

        // ë¦¬ì†ŒìŠ¤ì—ì„œ ìƒ˜í”Œë§ëœ ë¹„íŠ¸ë§µ ë””ì½”ë”©
        val bitmap = decodeSampledBitmapFromResource(
            res = applicationContext.resources,
            resId = imageId,
            reqWidth = 100, // ëŒ€ìƒ ë„ˆë¹„
            reqHeight = 100 // ëŒ€ìƒ ë†’ì´
        )

        // ë¹„íŠ¸ë§µì„ ë©”ëª¨ë¦¬ ìºì‹œì— ì¶”ê°€
        bitmap?.let {
            LruCacheManager.memoryCache.put(imageId.toString(), it)
            return Result.success()
        }

        return Result.failure()
    }
}
```
ì—¬ê¸°ì„œ ë©”ëª¨ë¦¬ í•¸ë“¤ë§ ë¡œì§ì— SoftReference/WeakReferenceëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ â†’ ê³µê²©ì ì¸ GCë¡œ ìºì‹±ê°’ ì‹ ë¢° ë¶ˆê°€ ë•Œë¬¸



#### DiskLruCacheë¥¼ ì‚¬ìš©í•œ ë””ìŠ¤í¬ ìºì‹±

- ë¹„íŠ¸ë§µì´ ì•± ì„¸ì…˜ ê°„ì— ì§€ì†ë˜ê³  ì¬ê³„ì‚°ì„ í”¼í•˜ë„ë¡ ë³´ì¥í•˜ë ¤ë©´ DiskLruCache ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¹„íŠ¸ë§µì„ ë””ìŠ¤í¬ì— ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- íŠ¹íˆ ë¦¬ì†ŒìŠ¤ ì§‘ì•½ì ì¸ ì´ë¯¸ì§€ë‚˜ ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•œ ì´ë¯¸ì§€ ëª©ë¡ì„ ì²˜ë¦¬í•  ë•Œ ìœ ìš©

ë¨¼ì €, ë””ì½”ë”©ëœ ë¹„íŠ¸ë§µì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ì•ˆì „í•œ í•´ì‹± ë° I/O ë¡œì§ìœ¼ë¡œ [DiskLruCache](https://github.com/JakeWharton/DiskLruCache)ë¥¼ ë˜í•‘í•˜ëŠ” DiskCacheManagerë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```kotlin
import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import com.jakewharton.disklrucache.DiskLruCache
import java.io.File
import java.io.IOException
import java.io.OutputStream
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException

class DiskCacheManager(context: Context, cacheDirName: String = "images", cacheSize: Long = 10 * 1024 * 1024) {

    private var diskLruCache: DiskLruCache? = null
    private val lock = Any()

    init {
        val cacheDir = getDiskCacheDir(context, cacheDirName)
        if (!cacheDir.exists()) {
            cacheDir.mkdirs()
        }
        try {
            // DiskLruCache ì—´ê¸° (ì•± ë²„ì „, ê°’ ê°œìˆ˜, ìµœëŒ€ í¬ê¸°)
            diskLruCache = DiskLruCache.open(cacheDir, 1, 1, cacheSize)
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    private fun getDiskCacheDir(context: Context, uniqueName: String): File {
        val cachePath = context.cacheDir.path
        return File(cachePath + File.separator + uniqueName)
    }

    // í‚¤ë¥¼ ì•ˆì „í•œ íŒŒì¼ ì´ë¦„ìœ¼ë¡œ ë³€í™˜ (SHA-1 ì‚¬ìš©)
    private fun filenameForKey(key: String): String {
        return try {
            val messageDigest = MessageDigest.getInstance("SHA-1")
            messageDigest.update(key.toByteArray())
            bytesToHexString(messageDigest.digest())
        } catch (e: NoSuchAlgorithmException) {
            key.hashCode().toString() // fallback
        }
    }

    private fun bytesToHexString(bytes: ByteArray): String {
        val sb = StringBuilder()
        for (b in bytes) {
            val hex = Integer.toHexString(0xFF and b.toInt())
            if (hex.length == 1) {
                sb.append('0')
            }
            sb.append(hex)
        }
        return sb.toString()
    }

    // ë””ìŠ¤í¬ ìºì‹œì—ì„œ ë¹„íŠ¸ë§µ ê°€ì ¸ì˜¤ê¸°
    fun get(key: String): Bitmap? {
        synchronized(lock) {
            val safeKey = filenameForKey(key)
            var snapshot: DiskLruCache.Snapshot? = null
            return try {
                snapshot = diskLruCache?.get(safeKey)
                snapshot?.getInputStream(0)?.use { inputStream ->
                    BitmapFactory.decodeStream(inputStream)
                }
            } catch (e: IOException) {
                e.printStackTrace()
                null
            } finally {
                snapshot?.close()
            }
        }
    }

    // ë””ìŠ¤í¬ ìºì‹œì— ë¹„íŠ¸ë§µ ì„¤ì •í•˜ê¸°
    fun set(key: String, bitmap: Bitmap) {
        synchronized(lock) {
            val safeKey = filenameForKey(key)
            var editor: DiskLruCache.Editor? = null
            try {
                editor = diskLruCache?.edit(safeKey)
                if (editor != null) {
                    editor.newOutputStream(0).use { outputStream ->
                        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)
                        editor.commit()
                    }
                } else {
                    diskLruCache?.flush() // editorê°€ nullì´ë©´ flush ì‹œë„
                }
            } catch (e: IOException) {
                e.printStackTrace()
                try {
                    editor?.abort()
                } catch (ignored: IOException) {}
            }
        }
    }
}
```

ì´ í´ë˜ìŠ¤ëŠ” ë‹¤ìŒì„ ë³´ì¥í•©ë‹ˆë‹¤.

* ë””ìŠ¤í¬ ì•ˆì „í•œ SHA-1 ê¸°ë°˜ íŒŒì¼ ì´ë¦„ ìƒì„±
* ì•ˆì „í•œ I/O ì‘ì—…
* ë””ìŠ¤í¬ ìºì‹œì— ì¤‘ë³µìœ¼ë¡œ ë°ì´í„°ë¥¼ ì“°ëŠ” í–‰ìœ„ ë°©ì§€

ë‹¤ìŒìœ¼ë¡œ, Jetpack WorkManagerì˜ CoroutineWorkerë¥¼ ì‚¬ìš©í•˜ì—¬ ë©”ì¸ ìŠ¤ë ˆë“œ ì™¸ë¶€ì—ì„œ ë””ìŠ¤í¬ ìºì‹±ì„ ìˆ˜í–‰í•˜ê³  ë©”ëª¨ë¦¬ ë° ë””ìŠ¤í¬ ì „ëµì„ ì•ˆì „í•˜ê²Œ ê²°í•©í•©ë‹ˆë‹¤.

```kotlin
import androidx.work.*
import android.content.Context
import android.graphics.Bitmap
// DiskCacheManager ë° LruCacheManager í•„ìš”

class BitmapWorker(
    private val context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {

    // DiskCacheManager ì¸ìŠ¤í„´ìŠ¤ëŠ” ì‹±ê¸€í†¤ ë˜ëŠ” ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ ê´€ë¦¬í•´ì•¼ í•©ë‹ˆë‹¤.
    private val diskCacheManager = DiskCacheManager(context)

    override suspend fun doWork(): Result {
        val key = inputData.getString("imageKey") ?: return Result.failure()
        val resId = inputData.getInt("resId", -1)
        if (resId == -1) return Result.failure()

        // ë©”ëª¨ë¦¬ ìºì‹œ ë¨¼ì € í™•ì¸
        LruCacheManager.memoryCache.get(key)?.let {
            // ë©”ëª¨ë¦¬ ìºì‹œì— ì´ë¯¸ ìˆìœ¼ë©´ ì„±ê³µ
            return Result.success()
        }

        // ë””ìŠ¤í¬ ìºì‹œ í™•ì¸
        diskCacheManager.get(key)?.let { bitmapFromDisk ->
            // ë””ìŠ¤í¬ ìºì‹œì— ìˆìœ¼ë©´ ë©”ëª¨ë¦¬ ìºì‹œì— ì¶”ê°€í•˜ê³  ì„±ê³µ
            LruCacheManager.memoryCache.put(key, bitmapFromDisk)
            return Result.success()
        }

        // ìºì‹œì— ì—†ìœ¼ë©´ ë””ì½”ë”© ë° ìºì‹±
        val bitmap = decodeSampledBitmapFromResource(
            applicationContext.resources,
            resId,
            reqWidth = 100, // í•„ìš”í•œ í¬ê¸° ì§€ì •
            reqHeight = 100 // í•„ìš”í•œ í¬ê¸° ì§€ì •
        )

        // ë¹„íŠ¸ë§µì„ ë©”ëª¨ë¦¬ ë° ë””ìŠ¤í¬ ìºì‹œì— ì¶”ê°€
        return try {
            bitmap?.let {
                addBitmapToCache(diskCacheManager, key, it)
                Result.success()
            } ?: Result.failure() // ë””ì½”ë”© ì‹¤íŒ¨
        } catch (e: Exception) {
            Result.failure()
        }
    }

    private fun addBitmapToCache(diskCacheManager: DiskCacheManager, key: String, bitmap: Bitmap) {
        // ë©”ëª¨ë¦¬ ìºì‹œì— ì¶”ê°€ (ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°)
        if (LruCacheManager.memoryCache.get(key) == null) {
            LruCacheManager.memoryCache.put(key, bitmap)
        }

        // ë””ìŠ¤í¬ ìºì‹œì— ì¶”ê°€ (ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°)
        // DiskCacheManager.set ë©”ì„œë“œ ë‚´ë¶€ì—ì„œ ì¤‘ë³µ í™•ì¸í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë°”ë¡œ í˜¸ì¶œ
        diskCacheManager.set(key, bitmap)
    }

    // decodeSampledBitmapFromResource í•¨ìˆ˜ êµ¬í˜„ í•„ìš” (Q45 ì˜ˆì œ ì°¸ì¡°)
    private fun decodeSampledBitmapFromResource(res: Resources, resId: Int, reqWidth: Int, reqHeight: Int): Bitmap? {
        // ... (Q45ì˜ í•¨ìˆ˜ êµ¬í˜„) ...
        return null // ì‹¤ì œ êµ¬í˜„ í•„ìš”
    }
}
```

ìœ„ì˜ WorkManagerëŠ” ë‹¤ìŒì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

* ê°€ëŠ¥í•˜ë©´ ë””ìŠ¤í¬ ìºì‹œì—ì„œ ì½ìŠµë‹ˆë‹¤.
* ë””ì½”ë”©ìœ¼ë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤.
* ê²°ê³¼ë¥¼ ë©”ëª¨ë¦¬ ë° ë””ìŠ¤í¬ ìºì‹œ ëª¨ë‘ì— ì €ì¥í•©ë‹ˆë‹¤.
* ì½”ë£¨í‹´ì„ í™œìš©í•˜ì—¬ ë©”ì¸ ìŠ¤ë ˆë“œ ì™¸ë¶€ì—ì„œ ì•ˆì „í•˜ê²Œ ì‹¤í–‰í•©ë‹ˆë‹¤.

#### ìš”ì•½

- ì•ˆë“œë¡œì´ë“œì—ì„œ í° Bitmapì„ íš¨ìœ¨ì ìœ¼ë¡œ ìºì‹œí•˜ë ¤ë©´ ë¹ ë¥¸ ìµœê·¼ì— ì ‘ê·¼í–ˆë˜ ë©”ëª¨ë¦¬ ìºì‹±ì„ ìœ„í•´ LruCacheë¥¼ ì‚¬ìš©í•˜ê³ , ì•± ì„¸ì…˜ì„ ë„˜ì–´ Bitmapì„ ìœ ì§€í•˜ê¸° ìœ„í•´ DiskLruCacheë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ë‘ ì „ëµì„ í•˜ì´ë¸Œë¦¬ë“œ í˜•íƒœë¡œ ê²°í•©í•˜ê³  êµ¬ì„± ë³€ê²½ ì‹œ ë©”ëª¨ë¦¬ ìºì‹œë¥¼ ìœ ì§€í•˜ì—¬ ì›í™œí•œ ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤.
- WorkManagerë¥¼ ì‚¬ìš©í•œ ì ì ˆí•œ ì´ˆê¸°í™” ë° ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì„ í†µí•´ í° ë¹„íŠ¸ë§µìœ¼ë¡œ ì‘ì—…í•  ë•Œ ì•± ì„±ëŠ¥ê³¼ ì‚¬ìš©ì ê²½í—˜ì„ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
