## Q) 63. 네트워크에서 이미지를 어떻게 가져오고 렌더링하나요?

* 핵심: 직접 구현 대신 **검증된 이미지 로딩 라이브러리**를 사용해 다운로드·리사이즈·캐싱·렌더링·메모리 관리를 일괄 해결.
* 대표 선택지: [Glide](https://github.com/bumptech/glide), [Coil](https://github.com/coil-kt/coil), [Fresco](https://github.com/facebook/fresco).
* 선택 기준: 프로젝트 성격(Compose/Kotlin 우선 여부, 복잡한 파이프라인 필요성, 메모리 제약)에 따라 결정하고, **캐싱/에러 처리/리소스 관리**를 일관 적용.

### Glide

* 오랜 기간 널리 사용된 이미지 로더. **캐싱/플레이스홀더/변환/GIF** 등 복잡 시나리오에 강함.
* 많은 글로벌 제품과 구글 오픈 소스 프로젝트에서도 사용. 가이드: [placeholders](https://bumptech.github.io/glide/doc/placeholders.html), [transformations](https://bumptech.github.io/glide/doc/transformations.html), [caching](https://bumptech.github.io/glide/doc/caching.html), [resource reuse](https://bumptech.github.io/glide/doc/resourcereuse.html).

```kotlin
Glide.with(context)
    .load("https://example.com/image.jpg") // 이미지 URL
    .placeholder(R.drawable.placeholder) // 로딩 중 표시할 이미지
    .error(R.drawable.error_image) // 오류 시 표시할 이미지
    .circleCrop() // 원형 자르기 변환 (선택 사항)
    .transition(DrawableTransitionOptions.withCrossFade()) // 페이드 효과 (선택 사항)
    .into(imageView) // 대상 ImageView
```

### Coil

* 100% Kotlin, **Coroutines/OkHttp** 기반. **Jetpack Compose·KMP**와 자연스러운 통합.
* 가볍고 현대적인 API. 기능: [GIF](https://coil-kt.github.io/coil/gifs/), [SVG](https://coil-kt.github.io/coil/svgs/), [비디오 프레임](https://coil-kt.github.io/coil/videos/).

```kotlin
import coil.load
import coil.transform.CircleCropTransformation

imageView.load("https://example.com/image.jpg") {
    crossfade(true) // 크로스페이드 효과
    placeholder(R.drawable.placeholder)
    error(R.drawable.error_image)
    transformations(CircleCropTransformation()) // 원형 자르기 변환
    // size(Size.ORIGINAL) // 원본 크기 로드 (선택 사항)
    // memoryCachePolicy(CachePolicy.ENABLED) // 메모리 캐시 정책 설정
    // diskCachePolicy(CachePolicy.ENABLED) // 디스크 캐시 정책 설정
}
```

* 현재 **활발한 유지보수**와 **Compose/KMP** 지원으로 최신 프로젝트에 특히 적합.

### Fresco

* [Meta](https://github.com/facebook)에서 개발. **독자적 이미지 파이프라인**과 `SimpleDraweeView` 제공.
* **큰 이미지, 점진적 로딩, 고급 캐싱**에 강함. (과거 안드로이드 4.x 최적화 이점은 현재 영향 축소)
* 참고: [공식 문서](https://frescolib.org/).

```kotlin
// Fresco 초기화 (Application 클래스에서)
// Fresco.initialize(this);

// 레이아웃에서 SimpleDraweeView 사용
val draweeView: SimpleDraweeView = findViewById(R.id.drawee_view)
val uri = Uri.parse("https://example.com/image.jpg")
draweeView.setImageURI(uri)

// 또는 Controller를 사용하여 더 세밀하게 제어
// val controller = Fresco.newDraweeControllerBuilder()
//    .setUri(uri)
//    .setOldController(draweeView.controller)
//    .build()
// draweeView.controller = controller
```

```xml
<com.facebook.drawee.view.SimpleDraweeView
    xmlns:fresco="http://schemas.android.com/apk/res-auto" <!-- 네임스페이스 추가 -->
    android:id="@+id/drawee_view"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    fresco:placeholderImage="@drawable/placeholder" <!-- 플레이스홀더 설정 -->
    fresco:failureImage="@drawable/error_image" <!-- 오류 이미지 설정 -->
    fresco:progressBarImage="@drawable/loading_spinner" <!-- 로딩 스피너 설정 -->
    />
```

### 요약

* **Glide**: 성숙한 생태계·풍부한 기능. 다양한 앱에서 검증. Jetpack Compose를 지원하지만 몇 년 동안 베타 상태.
* **Coil**: Kotlin/Compose/KMP 친화적, 경량·현대적 API, 활발한 유지보수.
* **Fresco**: 메모리 집약적인 시나리오에 적합하며 점진적 이미지 로딩, 이미지 파이프라인 및 더 복잡한 작업과 같은 고급 기능을 처리하는데 효율적.
* 어떤 라이브러리를 택하든 **캐싱 전략, 오류 처리, 리소스 관리**를 체계화해 **부드러운 UX**를 보장하는 것이 핵심.
