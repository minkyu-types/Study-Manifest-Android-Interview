## Q) 59. 장기적으로 실행되는 백그라운드 작업을 어떻게 관리하나요?

안드로이드는 작업의 **지속성(앱 종료/재부팅 이후 실행 보장)**, **사용자 인지 필요 여부**, **즉시성/주기성**, **리소스 제약(네트워크/충전 등)** 에 따라 선택지가 달라집니다. 핵심은:

* **WorkManager**(영구·제약 기반), **Service/Foreground Service**(연속·사용자 인지),
* **Kotlin Coroutines**(수명주기 연동 단기 작업), **JobScheduler**(시스템 수준 조건·지연 가능) 중 올바른 조합을 택하는 것.

### 조건부 작업에 적합한 [WorkManager](https://developer.android.com/develop/background-work/background-tasks/persistent)

* 앱 종료·재부팅 후에도 **보장 실행**이 필요한 영구 작업(로그/동기화/업로드 등).
* 네트워크/충전 등 **제약 조건**을 만족할 때 안전 실행.
* 일반적 상황에선 **WorkManager 먼저 고려**(내부적으로 JobScheduler 등 사용).

```kotlin
class UploadWorker(appContext: Context, workerParams: WorkerParameters) : Worker(appContext, workerParams) {
    override fun doWork(): Result {
        // 여기서 백그라운드 작업 수행
        uploadData()
        return Result.success()
    }
}

// 작업 예약
val constraints = Constraints.Builder()
    .setRequiredNetworkType(NetworkType.CONNECTED) // 네트워크 연결 필요 제약 조건
    .build()

val workRequest = OneTimeWorkRequestBuilder<UploadWorker>()
    .setConstraints(constraints)
    .build()

WorkManager.getInstance(context).enqueue(workRequest)
```

### 오랜 작업에 적합한 Service

* 음악 재생, 위치 추적처럼 **지속 실행**이 본질인 작업.
* 사용자 인지가 필요한 경우 **Foreground Service**(알림 필수).
* `onStartCommand` 반환 정책(예: `START_NOT_STICKY`)을 의도에 맞게 선택.
  * START_STICKY: 서비스가 강제로 종료되었을 때 시스템이 자동으로 다시 시작하도록 하는 방식.
  * START_NOT_STICKY: 서비스가 강제로 종료되었을 때 시스템이 서비스를 자동으로 다시 시작하지 않도록 하는 방식.
  * START_REDELIVER_INTENT: 서비스가 강제로 종료되었을 때 시스템이 자동으로 서비스를 다시 시작하고 마지막으로 전달된 Intent를 다시 전달하도록 하는 방식.

```kotlin
class MyForegroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // 장기 실행 작업 수행
        startForeground(NOTIFICATION_ID, createNotification())
        // START_STICKY, START_REDELIVER_INTENT 등 반환 값 고려
        return START_NOT_STICKY
    }

    // 알림 생성 로직 (Notification Channel 포함)
    private fun createNotification(): Notification {
        // ...
        return NotificationCompat.Builder(this, CHANNEL_ID).build()
    }

    override fun onBind(intent: Intent?): IBinder? = null
}
```

### Kotlin Coroutines 및 Dispatchers 사용하기

* 화면/수명주기에 **연동된 단기 작업**(앱 종료 후 보장 X).
* I/O는 `Dispatchers.IO`, CPU 연산은 `Dispatchers.Default`로 **적절 분리**.
* UI 업데이트 시 `withContext(Dispatchers.Main)`로 전환.

```kotlin
class MyViewModel : ViewModel() {
    fun fetchData() {
        viewModelScope.launch(Dispatchers.IO) { // IO 디스패처에서 네트워크 작업 실행
            val data = fetchFromNetwork()
            // 결과를 메인 스레드로 전환하여 UI 업데이트
            withContext(Dispatchers.Main) {
                updateUI(data)
            }
        }
    }
}
```

#### 💡 Additional Tips (CPU vs I/O)

* **CPU 집약적**: 암호화/이미지 처리/인코딩/분석 등 연산 중심 → **코어 수 만큼 병렬**이 이점, 과도한 스레드는 경합 유발.
* **I/O 바운드**: 네트워크/디스크 대기 중심 → **동시성 확대 유리**, 코루틴으로 적은 스레드로 대량 처리 효율적.<br>

이와 관련하여 더 자세히 학습하고 싶으시다면 [Understanding Coroutines Dispatchers](https://proandroiddev.com/understanding-coroutines-dispatchers-2578dc577851) 포스트를 참고하시길 바랍니다.

### 시스템 수준 작업에 적합한 JobScheduler

* 충전 중·비과금 네트워크 등 **시스템 전역 조건** 기반, **즉시 실행이 필요하지 않은 작업에 적합**.
* 특수 케이스가 아니면 보통 **WorkManager 권장**.(WorkManager는 어차피 내부적으로 JobScheduler 등을 활용)

```kotlin
val jobScheduler = context.getSystemService(JobScheduler::class.java)
val jobInfo = JobInfo.Builder(JOB_ID, ComponentName(context, MyJobService::class.java))
    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) // 네트워크에 연결 중인 상황에만 실행
    .setRequiresCharging(true) // 충전 중인 상황에만 실행
    .setPeriodic(TimeUnit.MINUTES.toMillis(15)) // 작업 주기 설정
    .build()

jobScheduler.schedule(jobInfo)
```

### 요약

* **WorkManager**: 영구·재부팅 후 재시도 + **제약 조건** 기반 보장 실행.
* **Service / Foreground Service**: 사용자 인지 필요한 **연속·장기 작업**.
* **Coroutines**: **수명주기 연동 단기 작업**(I/O vs CPU 디스패처 분리, 메인 전환).
* **JobScheduler**: 시스템 조건 기반 **지연/주기 작업**(특수 상황, 보통 WorkManager로 대체).
