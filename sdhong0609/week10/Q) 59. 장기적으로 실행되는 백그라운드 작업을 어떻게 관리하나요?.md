## Q) 59. ì¥ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì„ ì–´ë–»ê²Œ ê´€ë¦¬í•˜ë‚˜ìš”?

ì•ˆë“œë¡œì´ë“œëŠ” ì‘ì—…ì˜ **ì§€ì†ì„±(ì•± ì¢…ë£Œ/ì¬ë¶€íŒ… ì´í›„ ì‹¤í–‰ ë³´ì¥)**, **ì‚¬ìš©ì ì¸ì§€ í•„ìš” ì—¬ë¶€**, **ì¦‰ì‹œì„±/ì£¼ê¸°ì„±**, **ë¦¬ì†ŒìŠ¤ ì œì•½(ë„¤íŠ¸ì›Œí¬/ì¶©ì „ ë“±)** ì— ë”°ë¼ ì„ íƒì§€ê°€ ë‹¬ë¼ì§‘ë‹ˆë‹¤. í•µì‹¬ì€:

* **WorkManager**(ì˜êµ¬Â·ì œì•½ ê¸°ë°˜), **Service/Foreground Service**(ì—°ì†Â·ì‚¬ìš©ì ì¸ì§€),
* **Kotlin Coroutines**(ìˆ˜ëª…ì£¼ê¸° ì—°ë™ ë‹¨ê¸° ì‘ì—…), **JobScheduler**(ì‹œìŠ¤í…œ ìˆ˜ì¤€ ì¡°ê±´Â·ì§€ì—° ê°€ëŠ¥) ì¤‘ ì˜¬ë°”ë¥¸ ì¡°í•©ì„ íƒí•˜ëŠ” ê²ƒ.

### ì¡°ê±´ë¶€ ì‘ì—…ì— ì í•©í•œ [WorkManager](https://developer.android.com/develop/background-work/background-tasks/persistent)

* ì•± ì¢…ë£ŒÂ·ì¬ë¶€íŒ… í›„ì—ë„ **ë³´ì¥ ì‹¤í–‰**ì´ í•„ìš”í•œ ì˜êµ¬ ì‘ì—…(ë¡œê·¸/ë™ê¸°í™”/ì—…ë¡œë“œ ë“±).
* ë„¤íŠ¸ì›Œí¬/ì¶©ì „ ë“± **ì œì•½ ì¡°ê±´**ì„ ë§Œì¡±í•  ë•Œ ì•ˆì „ ì‹¤í–‰.
* ì¼ë°˜ì  ìƒí™©ì—ì„  **WorkManager ë¨¼ì € ê³ ë ¤**(ë‚´ë¶€ì ìœ¼ë¡œ JobScheduler ë“± ì‚¬ìš©).

```kotlin
class UploadWorker(appContext: Context, workerParams: WorkerParameters) : Worker(appContext, workerParams) {
    override fun doWork(): Result {
        // ì—¬ê¸°ì„œ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ìˆ˜í–‰
        uploadData()
        return Result.success()
    }
}

// ì‘ì—… ì˜ˆì•½
val constraints = Constraints.Builder()
    .setRequiredNetworkType(NetworkType.CONNECTED) // ë„¤íŠ¸ì›Œí¬ ì—°ê²° í•„ìš” ì œì•½ ì¡°ê±´
    .build()

val workRequest = OneTimeWorkRequestBuilder<UploadWorker>()
    .setConstraints(constraints)
    .build()

WorkManager.getInstance(context).enqueue(workRequest)
```

### ì˜¤ëœ ì‘ì—…ì— ì í•©í•œ Service

* ìŒì•… ì¬ìƒ, ìœ„ì¹˜ ì¶”ì ì²˜ëŸ¼ **ì§€ì† ì‹¤í–‰**ì´ ë³¸ì§ˆì¸ ì‘ì—….
* ì‚¬ìš©ì ì¸ì§€ê°€ í•„ìš”í•œ ê²½ìš° **Foreground Service**(ì•Œë¦¼ í•„ìˆ˜).
* `onStartCommand` ë°˜í™˜ ì •ì±…(ì˜ˆ: `START_NOT_STICKY`)ì„ ì˜ë„ì— ë§ê²Œ ì„ íƒ.
  * START_STICKY: ì„œë¹„ìŠ¤ê°€ ê°•ì œë¡œ ì¢…ë£Œë˜ì—ˆì„ ë•Œ ì‹œìŠ¤í…œì´ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘í•˜ë„ë¡ í•˜ëŠ” ë°©ì‹.
  * START_NOT_STICKY: ì„œë¹„ìŠ¤ê°€ ê°•ì œë¡œ ì¢…ë£Œë˜ì—ˆì„ ë•Œ ì‹œìŠ¤í…œì´ ì„œë¹„ìŠ¤ë¥¼ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘í•˜ì§€ ì•Šë„ë¡ í•˜ëŠ” ë°©ì‹.
  * START_REDELIVER_INTENT: ì„œë¹„ìŠ¤ê°€ ê°•ì œë¡œ ì¢…ë£Œë˜ì—ˆì„ ë•Œ ì‹œìŠ¤í…œì´ ìë™ìœ¼ë¡œ ì„œë¹„ìŠ¤ë¥¼ ë‹¤ì‹œ ì‹œì‘í•˜ê³  ë§ˆì§€ë§‰ìœ¼ë¡œ ì „ë‹¬ëœ Intentë¥¼ ë‹¤ì‹œ ì „ë‹¬í•˜ë„ë¡ í•˜ëŠ” ë°©ì‹.

```kotlin
class MyForegroundService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // ì¥ê¸° ì‹¤í–‰ ì‘ì—… ìˆ˜í–‰
        startForeground(NOTIFICATION_ID, createNotification())
        // START_STICKY, START_REDELIVER_INTENT ë“± ë°˜í™˜ ê°’ ê³ ë ¤
        return START_NOT_STICKY
    }

    // ì•Œë¦¼ ìƒì„± ë¡œì§ (Notification Channel í¬í•¨)
    private fun createNotification(): Notification {
        // ...
        return NotificationCompat.Builder(this, CHANNEL_ID).build()
    }

    override fun onBind(intent: Intent?): IBinder? = null
}
```

### Kotlin Coroutines ë° Dispatchers ì‚¬ìš©í•˜ê¸°

* í™”ë©´/ìˆ˜ëª…ì£¼ê¸°ì— **ì—°ë™ëœ ë‹¨ê¸° ì‘ì—…**(ì•± ì¢…ë£Œ í›„ ë³´ì¥ X).
* I/OëŠ” `Dispatchers.IO`, CPU ì—°ì‚°ì€ `Dispatchers.Default`ë¡œ **ì ì ˆ ë¶„ë¦¬**.
* UI ì—…ë°ì´íŠ¸ ì‹œ `withContext(Dispatchers.Main)`ë¡œ ì „í™˜.

```kotlin
class MyViewModel : ViewModel() {
    fun fetchData() {
        viewModelScope.launch(Dispatchers.IO) { // IO ë””ìŠ¤íŒ¨ì²˜ì—ì„œ ë„¤íŠ¸ì›Œí¬ ì‘ì—… ì‹¤í–‰
            val data = fetchFromNetwork()
            // ê²°ê³¼ë¥¼ ë©”ì¸ ìŠ¤ë ˆë“œë¡œ ì „í™˜í•˜ì—¬ UI ì—…ë°ì´íŠ¸
            withContext(Dispatchers.Main) {
                updateUI(data)
            }
        }
    }
}
```

#### ğŸ’¡ Additional Tips (CPU vs I/O)

* **CPU ì§‘ì•½ì **: ì•”í˜¸í™”/ì´ë¯¸ì§€ ì²˜ë¦¬/ì¸ì½”ë”©/ë¶„ì„ ë“± ì—°ì‚° ì¤‘ì‹¬ â†’ **ì½”ì–´ ìˆ˜ ë§Œí¼ ë³‘ë ¬**ì´ ì´ì , ê³¼ë„í•œ ìŠ¤ë ˆë“œëŠ” ê²½í•© ìœ ë°œ.
* **I/O ë°”ìš´ë“œ**: ë„¤íŠ¸ì›Œí¬/ë””ìŠ¤í¬ ëŒ€ê¸° ì¤‘ì‹¬ â†’ **ë™ì‹œì„± í™•ëŒ€ ìœ ë¦¬**, ì½”ë£¨í‹´ìœ¼ë¡œ ì ì€ ìŠ¤ë ˆë“œë¡œ ëŒ€ëŸ‰ ì²˜ë¦¬ íš¨ìœ¨ì .<br>

ì´ì™€ ê´€ë ¨í•˜ì—¬ ë” ìì„¸íˆ í•™ìŠµí•˜ê³  ì‹¶ìœ¼ì‹œë‹¤ë©´ [Understanding Coroutines Dispatchers](https://proandroiddev.com/understanding-coroutines-dispatchers-2578dc577851) í¬ìŠ¤íŠ¸ë¥¼ ì°¸ê³ í•˜ì‹œê¸¸ ë°”ëë‹ˆë‹¤.

### ì‹œìŠ¤í…œ ìˆ˜ì¤€ ì‘ì—…ì— ì í•©í•œ JobScheduler

* ì¶©ì „ ì¤‘Â·ë¹„ê³¼ê¸ˆ ë„¤íŠ¸ì›Œí¬ ë“± **ì‹œìŠ¤í…œ ì „ì—­ ì¡°ê±´** ê¸°ë°˜, **ì¦‰ì‹œ ì‹¤í–‰ì´ í•„ìš”í•˜ì§€ ì•Šì€ ì‘ì—…ì— ì í•©**.
* íŠ¹ìˆ˜ ì¼€ì´ìŠ¤ê°€ ì•„ë‹ˆë©´ ë³´í†µ **WorkManager ê¶Œì¥**.(WorkManagerëŠ” ì–´ì°¨í”¼ ë‚´ë¶€ì ìœ¼ë¡œ JobScheduler ë“±ì„ í™œìš©)

```kotlin
val jobScheduler = context.getSystemService(JobScheduler::class.java)
val jobInfo = JobInfo.Builder(JOB_ID, ComponentName(context, MyJobService::class.java))
    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) // ë„¤íŠ¸ì›Œí¬ì— ì—°ê²° ì¤‘ì¸ ìƒí™©ì—ë§Œ ì‹¤í–‰
    .setRequiresCharging(true) // ì¶©ì „ ì¤‘ì¸ ìƒí™©ì—ë§Œ ì‹¤í–‰
    .setPeriodic(TimeUnit.MINUTES.toMillis(15)) // ì‘ì—… ì£¼ê¸° ì„¤ì •
    .build()

jobScheduler.schedule(jobInfo)
```

### ìš”ì•½

* **WorkManager**: ì˜êµ¬Â·ì¬ë¶€íŒ… í›„ ì¬ì‹œë„ + **ì œì•½ ì¡°ê±´** ê¸°ë°˜ ë³´ì¥ ì‹¤í–‰.
* **Service / Foreground Service**: ì‚¬ìš©ì ì¸ì§€ í•„ìš”í•œ **ì—°ì†Â·ì¥ê¸° ì‘ì—…**.
* **Coroutines**: **ìˆ˜ëª…ì£¼ê¸° ì—°ë™ ë‹¨ê¸° ì‘ì—…**(I/O vs CPU ë””ìŠ¤íŒ¨ì²˜ ë¶„ë¦¬, ë©”ì¸ ì „í™˜).
* **JobScheduler**: ì‹œìŠ¤í…œ ì¡°ê±´ ê¸°ë°˜ **ì§€ì—°/ì£¼ê¸° ì‘ì—…**(íŠ¹ìˆ˜ ìƒí™©, ë³´í†µ WorkManagerë¡œ ëŒ€ì²´).
