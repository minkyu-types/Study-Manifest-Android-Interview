## Q) 62. 대규모 데이터 셋을 효율적으로 로드하는 데 왜 페이징 기법이 필요하고, RecyclerView로 구현해 본 경험이 있나요?

* **왜 필요한가**

    * 메모리 절감: 한 번에 전부 로드하지 않고 **페이지 단위로 청크**를 가져와 OOM(메모리 부족) 리스크 감소.
    * **초기 로드 시간 단축**: 화면에 필요한 최소 데이터만 먼저 렌더링.
    * **네트워크 사용량 최적화**: 필요한 시점에만 추가 페이지 요청(대역폭 절약).
    * **UX 향상**: 스크롤 진행에 맞춘 **동적 로딩**으로 부드러운 리스트/그리드 경험(무한 스크롤에 적합).

### 페이징 시스템 직접 구현

* 핵심 아이디어

    * `ListAdapter + DiffUtil`로 효율적 갱신.
    * `addOnScrollListener`로 **미리 당겨오기(threshold prefetch)** 트리거.
    * `viewModel.isLoading` 등으로 **중복 로딩 방지**, 성공 시 `submitList()`로 합치기.

```kotlin
class PokedexAdapter: ListAdapter<Pokemon, PokedexAdapter.PokedexViewHolder>(diffUtil) {

    override fun onCreateViewHolder(
        parent: ViewGroup,
        viewType: Int
    ): PokedexViewHolder {
        val binding = ItemPokemonBinding.inflate(LayoutInflater.from(parent.context), parent, false) // parent 전달
        return PokedexViewHolder(binding)
    }

    override fun onBindViewHolder(holder: PokedexViewHolder, position: Int) {
        // getItem()으로 안전하게 아이템 가져오기
        holder.bind(getItem(position))
    }

    inner class PokedexViewHolder(
        private val binding: ItemPokemonBinding,
    ) : RecyclerView.ViewHolder(binding.root) {
        fun bind(pokemon: Pokemon) {
            // 데이터 바인딩 로직
        }
    }

    companion object {
        private val diffUtil = object : DiffUtil.ItemCallback<Pokemon>() {
            override fun areItemsTheSame(oldItem: Pokemon, newItem: Pokemon): Boolean =
                oldItem.name == newItem.name

            override fun areContentsTheSame(oldItem: Pokemon, newItem: Pokemon): Boolean =
                oldItem == newItem
        }
    }
}
```

```kotlin
recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {
    override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
        super.onScrolled(recyclerView, dx, dy)
        // 레이아웃 매니저 가져오기 (LinearLayoutManager 또는 GridLayoutManager)
        val layoutManager = recyclerView.layoutManager ?: return // Null 체크

        val lastVisiblePosition = when (layoutManager) {
            is LinearLayoutManager -> layoutManager.findLastVisibleItemPosition()
            is GridLayoutManager -> layoutManager.findLastVisibleItemPosition()
            else -> return // 다른 레이아웃 매니저는 처리하지 않음
        }

        val totalItemCount = layoutManager.itemCount
        val threshold = 4 // 미리 로드할 아이템 개수 (임계값)

        // 마지막 아이템에 가까워지고 로딩 중이 아닐 때 다음 페이지 미리 로드
        if (lastVisiblePosition + threshold >= totalItemCount && totalItemCount > 0 && !viewModel.isLoading.value) {
            viewModel.loadNextPage()
        }
    }
})
```

`viewModel.loadNextPage()` 성공 시 **신규 페이지를 기존 리스트에 병합**하고 `submitList()`(ListAdapter의 경우)로 UI 업데이트.

### 요약

* 직접 구현: **페이지 분할 + 스크롤 감지 + 어댑터 동적 갱신**으로 구현.
* [Jetpack Paging v3](https://developer.android.com/topic/libraries/architecture/paging/v3-overview)를 황요하여 또다른 접근 방식으로 페이징 시스테 구현 가능.
* [RecyclerViewPaginator](https://github.com/skydoves/BaseRecyclerViewAdapter?tab=readme-ov-file#recyclerviewpaginator) 라이브러리로 커스텀 접근 방식 학습 가능.
