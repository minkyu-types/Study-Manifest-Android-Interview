## Q) 60. Json 형식을 객체로 어떻게 직렬화(serialize)하나요?

* 네트워크 통신(REST/GraphQL/Firebase 등)에서 **객체 ⇄ JSON** 변환은 필수.
* 선택 기준: **Kotlin 친화성**, **성능(리플렉션 vs 코드생성)**, **멀티플랫폼 필요성**, **에러 검출 시점(컴파일타임 vs 런타임)**.

### 직렬화(Serialization)와 역직렬화(Deserialization)

* **직렬화**: 메모리 객체 → 전송/저장용 포맷(JSON 등)으로 변환.
* **역직렬화**: 직렬화된 데이터(JSON 등) → 앱이 사용하는 객체로 재구성.

### 수동 직렬화/역직렬화 (학습·의존성 최소화 목적)

* 장점: 의존성 없음, 동작 원리 학습에 유용.
* 단점: 유지보수/안전성/확장성 한계로 **프로덕션 비권장**.
* 실전에서는 라이브러리(**[kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization)**, **[Moshi](https://github.com/square/moshi)**, **[Gson](https://github.com/google/gson)**) 사용 권장.

```kotlin
data class User(val name: String, val age: Int)

fun serializeUser(user: User): String {
    // 각 속성을 JSON 형식에 맞게 문자열로 변환
    return """{
        "name": "${user.name}",
        "age": ${user.age}
    }""".trimIndent() // 들여쓰기 제거
}

// 사용 예제
val user = User("John", 30)
val jsonString = serializeUser(user)
// 출력: {"name":"John","age":30}
```

```kotlin
fun deserializeUser(json: String): User {
    // 정규 표현식을 사용하여 값 추출 (간단한 예시)
    val nameRegex = """"name"\s*:\s*"([^"]*)"""".toRegex()
    val ageRegex = """"age"\s*:\s*(\d+)""".toRegex()

    val name = nameRegex.find(json)?.groups?.get(1)?.value ?: ""
    val age = ageRegex.find(json)?.groups?.get(1)?.value?.toIntOrNull() ?: 0

    return User(name, age)
}

// 사용 예제
val jsonString = """{"name":"John","age":30}"""
val user = deserializeUser(jsonString)
// 출력: User(name="John", age=30)
```

### kotlinx.serialization

* **Kotlin-first** 설계, 컴파일러 플러그인 기반(리플렉션 없음) → **가볍고 빠르며 컴파일타임 안전성** 높음.
* **KMP** 완전 지원(멀티플랫폼에 최적).
* 추천 상황: 최신 Android/KMP 프로젝트의 기본 선택지.

```kotlin
import kotlinx.serialization.*
import kotlinx.serialization.json.*

@Serializable // 직렬화 가능 클래스임을 명시
data class User(val name: String, val age: Int)

val json = """{"name": "John", "age": 30}"""
// JSON 문자열을 User 객체로 역직렬화
val user: User = Json.decodeFromString<User>(json)
// User 객체를 JSON 문자열로 직렬화
val serializedJson: String = Json.encodeToString(user)
```

### Moshi

* Kotlin nullability/기본값 지원이 자연스러움.
* 두 모드:

    * **리플렉션 모드**: 셋업 간단하지만 **런타임 오버헤드** 존재. 자세히: [reflection](https://github.com/square/moshi?tab=readme-ov-file#reflection)
    * **코드생성(Codegen)**: KSP로 어댑터를 **컴파일타임 생성** → **더 빠르고 타입 안전**. 자세히: [codegen](https://github.com/square/moshi?tab=readme-ov-file#codegen), [KSP](https://kotlinlang.org/docs/ksp-overview.html)
* 일반적으로 **Codegen 권장**.
* 참고: IR 기반 코드생성 대안 **[MoshiX](https://github.com/ZacSweers/MoshiX)**.

```kotlin
data class User(val name: String, val age: Int)

// Moshi 인스턴스 생성 (Kotlin 지원 추가 필요)
val moshi = Moshi.Builder()
    .add(KotlinJsonAdapterFactory()) // Kotlin 지원 추가
    .build()
// User 클래스에 대한 어댑터 가져오기
val adapter: JsonAdapter<User> = moshi.adapter(User::class.java)
val json = """{"name": "John", "age": 30}"""

// JSON을 객체로 역직렬화
val user: User? = adapter.fromJson(json)
// 객체를 JSON으로 직렬화
val serializedJson: String? = user?.let { adapter.toJson(it) }
```

### Gson

* 장점: **간단한 API**, JVM 프로젝트에 **통합 용이**.
* 한계: Kotlin 친화성 부족(기본값/nullable 등), **리플렉션 의존**(성능·메모리 불리), KMP 부적합, **런타임 오류** 유발 여지.
* 커뮤니티 비교 논의: [Moshi vs kotlinx.serialization with Retrofit](https://www.reddit.com/r/androiddev/comments/dhjdk2/moshi_vs_kotlinx_serilization_with_retrofit/), [Why use Moshi over Gson?](https://www.reddit.com/r/androiddev/comments/684flw/why_use_moshi_over_gson/)

```kotlin
data class User(val name: String, val age: Int)

val gson = Gson()
val json = """{"name": "John", "age": 30}"""
val user = gson.fromJson(json, User::class.java) // JSON을 객체로 역직렬화
val serializedJson = gson.toJson(user) // 객체를 JSON으로 직렬화
```

### 결론

* **[kotlinx.serialization](https://github.com/Kotlin/kotlinx.serialization)**: Kotlin 우선, 무리플렉션, **컴파일타임 안전성**, **KMP 지원** → 기본 추천.
* **[Moshi](https://github.com/square/moshi) Codegen**: Android 중심에서 **빠르고 안전**한 JSON 처리(현대적 기능·성능).
* **[Gson](https://github.com/google/gson)**: 쉬운 통합이 강점이지만, **Kotlin 친화성/성능/모범사례** 관점에서 뒤처짐.
