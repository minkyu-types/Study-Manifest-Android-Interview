## Q) 65. 오프라인 우선(offline-first) 아키텍처를 어떻게 설계하실 건가요?

* 네트워크가 불안정해도 **로컬 캐시/저장 데이터로 정상 동작**하고, 연결 복구 시 **원격과 동기화**하는 전략.
* 사용자 경험을 끊기지 않게 유지합니다.
* 자세한 가이드: [오프라인 우선에 대한 안드로이드 공식 문서](https://developer.android.com/topic/architecture/data-layer/offline-first)를 참고하세요.

### 오프라인 우선 아키텍처의 핵심 개념

1. **로컬 데이터 지속성**: Room으로 구조화된 데이터 관리. 코루틴·Flow/Livedata로 **반응형 UI 업데이트**.
2. **데이터 동기화**: WorkManager로 **조건부·지연 동기화** 실행(네트워크 연결 시), 실패 시 **자동 재시도**.
3. **캐시/가져오기 정책**:

   * 읽기: **로컬 우선 조회**, 필요 시 네트워크 최신화.
   * 쓰기: **로컬에 먼저 기록** 후 백그라운드 동기화.
4. **충돌 해결**:

   * **최신 변경 우선**(last-write-wins) 또는
   * **사용자 정의 규칙/수동 선택** 제공.

### 실제 구현

```kotlin
// 데이터 엔티티 (동기화 상태 플래그 포함)
@Entity
data class Article(
    @PrimaryKey val id: Int,
    val title: String,
    val content: String,
    val isSynced: Boolean = false // 서버와 동기화되었는지 여부
)

// DAO 인터페이스
@Dao
interface ArticleDao {
    @Query("SELECT * FROM Article")
    fun getAllArticles(): Flow<List<Article>> // Flow로 변경 사항 관찰

    // 로컬에만 있는 미동기화된 Article 조회
    @Query("SELECT * FROM Article WHERE isSynced = 0")
    suspend fun getUnsyncedArticles(): List<Article>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertArticle(article: Article)

    // 동기화 완료 후 상태 업데이트
    @Query("UPDATE Article SET isSynced = 1 WHERE id = :articleId")
    suspend fun markArticleAsSynced(articleId: Int)
}

// 동기화 Worker
class SyncWorker(appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {
    override suspend fun doWork(): Result {
        // 데이터베이스 및 DAO 인스턴스 가져오기 (의존성 주입 권장)
        val articleDao = AppDatabase.getInstance(applicationContext).articleDao()

        return try {
            // 미동기화된 데이터 가져오기
            val unsyncedArticles = articleDao.getUnsyncedArticles()

            if (unsyncedArticles.isNotEmpty()) {
                // 서버와 동기화 시도
                if (syncToServer(unsyncedArticles)) {
                    // 성공 시 로컬 상태 업데이트
                    unsyncedArticles.forEach {
                        articleDao.markArticleAsSynced(it.id)
                    }
                    Log.d("SyncWorker", "Sync successful for ${unsyncedArticles.size} articles.")
                } else {
                    Log.e("SyncWorker", "Sync failed.")
                    // 재시도 로직은 WorkManager가 처리하거나 여기서 명시적으로 Result.retry() 반환 가능
                    return Result.retry()
                }
            } else {
                Log.d("SyncWorker", "No articles to sync.")
            }
            Result.success()
        } catch (e: Exception) {
            Log.e("SyncWorker", "Sync failed with error", e)
            Result.failure() // 실패로 간주
        }
    }

    // 서버와 동기화하는 실제 로직 (네트워크 호출 등)
    private suspend fun syncToServer(articles: List<Article>): Boolean {
        // 실제 네트워크 요청 및 결과 처리 로직 구현
        Log.d("SyncWorker", "Attempting to sync ${articles.size} articles...")
        // 아래 예시에서는 가짜로 지연시키고 성공을 반환하고 있는데,
        // 실제 구현에서는 네트워크 요청 로직이 들어감
        kotlinx.coroutines.delay(2000)
        return true // 실제 구현에서는 API 호출 결과에 따라 반환
    }
}
```

* 앱 시작 시 1회 동기화 같은 전략은 App Startup로 트리거 가능.
* 실제 구현 예시는 GitHub의 [SyncWorker.kt](https://github.com/android/nowinandroid/blob/d42262c9391ccd1d59a0c92476c2b349a5acc3af/sync/work/src/main/kotlin/com/google/samples/apps/nowinandroid/sync/workers/SyncWorker.kt#L51), [SyncInitializer.kt](https://github.com/android/nowinandroid/blob/d42262c9391ccd1d59a0c92476c2b349a5acc3af/sync/work/src/main/kotlin/com/google/samples/apps/nowinandroid/sync/initializers/SyncInitializer.kt#L23) 참고.

### 요약

1. **WorkManager**로 백그라운드 동기화.
2. **Room**으로 로컬 영속성 및 반응형 스트림 제공.
3. **명확한 캐시 정책을 정의**(읽기 로컬 우선, 쓰기 후 비동기 동기화).
4. **충돌 해결 전략**(최신 우선/사용자 정의).

### 요약

오프라인 우선은 **연결 유무와 무관한 일관된 UX**를 목표로 합니다. Room·WorkManager·명시적 캐싱 정책을 결합해 오프라인에서도 동작하고, 온라인 복구 시 **자연스러운 동기화**로 일관성을 유지하세요. 더 자세한 가이드는 [공식 문서](https://developer.android.com/topic/architecture/data-layer/offline-first)에서 확인할 수 있습니다.
