## Q) 64. 로컬 디바이스에 데이터를 저장하고 복원하는 방법에 대해서 설명해 주세요.

* 안드로이드는 **키-값(설정/플래그)**, **관계형 구조 데이터**, **파일(바이너리/커스텀 포맷)** 등 **데이터 성격**에 맞춘 저장 메커니즘을 제공.
* 경량 설정 = SharedPreferences/DataStore
* 복잡한 쿼리나 대량의 구조화된 데이터 저장 = Room
* 바이너리 또는 커스텀 데이터 = File Storage

### SharedPreferences

* 가벼운 **키-값** 저장(설정/토글 등).
* 동기 API라 메인 스레드 차단 이슈 가능(KTX `edit {}`는 내부적으로 `apply()` 사용).
* 링크: [SharedPreferences](https://developer.android.com/training/data-storage/shared-preferences)

```kotlin
import androidx.core.content.edit // KTX 확장 함수 사용

val sharedPreferences = context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
// KTX 확장 함수를 사용하여 간단하게 데이터 수정 후 반영
sharedPreferences.edit {
    putString("user_name", "skydoves")
    putInt("user_score", 100)
    // apply()는 비동기, commit()은 동기
    // KTX edit {} 블록은 자동으로 apply() 호출
}

// 값 읽기
val userName = sharedPreferences.getString("user_name", null) // 기본값 지정
```

### DataStore

* **SharedPreferences 대체**: 비동기식으로 메인 스레드를 차단하는 잠재적인 문제를 방지.
* 두 종류: **PreferencesDataStore(키-값)**, **ProtoDataStore(스키마 기반 객체)**.
* 링크: [Jetpack DataStore](https://developer.android.com/topic/libraries/architecture/datastore)

```kotlin
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.runBlocking

// Context의 확장 함수로 DataStore 인스턴스 생성 (싱글톤 권장)
val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")

// 데이터 저장을 위한 키 정의
val USER_NAME_KEY = stringPreferencesKey("user_name")

// 데이터 쓰기 (코루틴 내에서 수행)
suspend fun saveUserName(context: Context, name: String) {
    context.dataStore.edit { settings ->
        settings[USER_NAME_KEY] = name
    }
}

// 데이터 읽기 (Flow 사용)
fun getUserNameFlow(context: Context): Flow<String?> {
    return context.dataStore.data
        .map { preferences ->
            preferences[USER_NAME_KEY] // 키에 해당하는 값 반환 (없으면 null)
        }
}

// 값 저장 및 복원 예시
fun exampleUsage(context: Context) {
    viewModelScope.launch {
        saveUserName(context, "John Doe")
        val name = getUserNameFlow(context).first() // Flow에서 첫 번째 값 가져오기
        Log.d("DataStore", "User name: $name")
    }
}
```

### Room Database

* **SQLite 추상화**로 엔티티/DAO/쿼리를 타입세이프로 관리, 컴파일타임 검사.
* **Flow/Livedata**로 변경 관찰, 대량/관계형/쿼리 중심 데이터에 적합.
* 링크: [Room Database](https://developer.android.com/training/data-storage/room)

```kotlin
// 데이터 엔티티 정의
@Entity(tableName = "users") // 테이블 이름 지정 (선택 사항)
data class User(
    @PrimaryKey val id: Int,
    @ColumnInfo(name = "user_name") val name: String // 컬럼 이름 지정 (선택 사항)
)

// 데이터 접근 객체(DAO) 정의
@Dao
interface UserDao {
    // suspend 함수로 비동기 처리
    @Insert(onConflict = OnConflictStrategy.REPLACE) // 크래시 발생 시 대체 전략
    suspend fun insertUser(user: User)

    @Query("SELECT * FROM users WHERE id = :userId") // 명확한 파라미터 이름 사용
    suspend fun getUserById(userId: Int): User? // Nullable 반환 타입

    @Query("SELECT * FROM users ORDER BY user_name ASC")
    fun getAllUsers(): Flow<List<User>> // Flow를 사용하여 데이터 변경 관찰
}

// 데이터베이스 클래스 정의
@Database(entities = [User::class], version = 1, exportSchema = false) // 스키마 내보내기 비활성화 (선택 사항)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao

    // 싱글톤 인스턴스 제공 (권장)
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database" // 데이터베이스 파일 이름
                )
                // .addMigrations(MIGRATION_1_2) // 마이그레이션 추가 (필요시)
                .build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

### File Storage

* **바이너리/커스텀 포맷** 저장에 적합.
* 내부 저장소(앱 전용, 안전) vs 외부 저장소(공유 가능, 권한/스토리지 스코프 주의).

```kotlin
// 내부 저장소의 앱별 디렉토리에 파일 생성
val file = File(context.filesDir, "user_data.txt")
try {
    FileOutputStream(file).use { fos ->
        fos.write("Sample user data".toByteArray())
    }
    // 또는 BufferedWriter 사용
    // file.bufferedWriter().use { out ->
    //     out.write("Sample user data")
    // }
} catch (e: IOException) {
    e.printStackTrace()
    // 오류 처리
}

// 파일 읽기 (예시)
try {
    val content = file.readText()
    Log.d("FileStorage", "File content: $content")
} catch (e: IOException) {
    e.printStackTrace()
}
```

### 요약

* **Preferences/DataStore**: 경량 키-값(설정/플래그). DataStore 권장(비동기·Flow).
* **Room**: 관계형/다중 엔티티/쿼리 중심 대용량 데이터.
* **File**: 이미지·동영상·커스텀 직렬화.
* 공통 체크리스트: **비동기 처리**, **마이그레이션/스키마 관리**, **암호화/백업 정책**, **I/O 오류 처리**까지 설계하면 안정적인 로컬 저장·복원이 가능.
