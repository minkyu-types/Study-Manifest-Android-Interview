## Q) 61. ì›ê²© ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ë©°, íš¨ìœ¨ì„±ê³¼ ì‹ ë¢°ì„±ì„ ìœ„í•´ ì–´ë–¤ ë¼ì´ë¸ŒëŸ¬ë¦¬ë‚˜ ê¸°ìˆ ì„ ì‚¬ìš©í•˜ë‚˜ìš”?

* í•µì‹¬: [Retrofit](https://square.github.io/retrofit/)ì€ ì„ ì–¸ì  APIë¡œ HTTP í˜¸ì¶œì„ ë‹¨ìˆœí™”í•˜ê³ , [OkHttp](https://square.github.io/okhttp/)ëŠ” ì—°ê²° í’€ë§Â·ìºì‹±Â·ì¸í„°ì…‰í„°ë¡œ ì „ì†¡ ê³„ì¸µì„ ì„¸ë°€ ì œì–´í•©ë‹ˆë‹¤.
* Retrofitì€ ConverterFactory(Gson/Moshi/kotlinx.serialization)ì™€ ì½”ë£¨í‹´ `suspend`ë¥¼ í†µí•´ íƒ€ì… ì„¸ì´í”„Â·ë¹„ë™ê¸° í˜¸ì¶œì„ ì‰½ê²Œ í•©ë‹ˆë‹¤.
* OkHttpëŠ” ì§ì ‘ ìš”ì²­/ì‘ë‹µì„ ë‹¤ë£¨ë©°, ì½œë°±/ì¸í„°ì…‰í„°ë¡œ ë¡œê¹…Â·ì¸ì¦ í—¤ë”Â·íƒ€ì„ì•„ì›ƒÂ·ìºì‹± ì •ì±…ì„ êµ¬ì„±í•©ë‹ˆë‹¤.
* Retrofit ë‚´ë¶€ í´ë¼ì´ì–¸íŠ¸ë¡œ OkHttpë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, **Retrofit + ì»¤ìŠ¤í…€ OkHttpClient** ì¡°í•©ìœ¼ë¡œ ë¡œê¹…/ì¸ì¦/íƒ€ì„ì•„ì›ƒì„ ì¼ê´€ë˜ê²Œ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### Retrofitì„ ì‚¬ìš©í•œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­

* ì„ ì–¸ì  ì¸í„°í˜ì´ìŠ¤ì— ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì—”ë“œí¬ì¸íŠ¸/HTTP ë©”ì„œë“œ ì •ì˜.
* ConverterFactoryë¡œ JSON â†” ê°ì²´ ë³€í™˜, `viewModelScope` + `try/catch`ë¡œ ì„±ê³µ/ì˜¤ë¥˜/ì˜ˆì™¸ ë¶„ê¸°.
* `isSuccessful`Â·`body` null ì²´í¬ ë° `errorBody` íŒŒì‹± ë“± ê¸°ë³¸ ì—ëŸ¬ ì²˜ë¦¬ íŒ¨í„´ í¬í•¨.

```kotlin
interface ApiService {
    @GET("data")
    // ì½”ë£¨í‹´ ì§€ì›ì„ ìœ„í•œ suspend í•¨ìˆ˜ ë˜ëŠ” Call<DataModel> ë°˜í™˜
    suspend fun fetchData(): Response<DataModel>
}
```

```kotlin
// Kotlinx Serialization Converter Factory ì˜ˆì‹œ
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .addConverterFactory(Json{ ignoreUnknownKeys = true } // ì•Œ ìˆ˜ ì—†ëŠ” í‚¤ ë¬´ì‹œ ì„¤ì • ì¶”ê°€
        .asConverterFactory("application/json".toMediaType()))
    .build()

// API ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
val apiService = retrofit.create(ApiService::class.java)
```

```kotlin
viewModelScope.launch { // ViewModel ìŠ¤ì½”í”„ ë˜ëŠ” ë‹¤ë¥¸ ì½”ë£¨í‹´ ìŠ¤ì½”í”„ ì‚¬ìš©
    try {
        val response = apiService.fetchData()
        if (response.isSuccessful) {
            // ì„±ê³µì ì¸ ì‘ë‹µ ì²˜ë¦¬
            val data = response.body()
            if (data != null) {  // Nullableì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ í™•ì¸ í•„ìš”
                Log.d(TAG, "Data fetched: $it")
                 // UI ì—…ë°ì´íŠ¸ ë˜ëŠ” ë°ì´í„° ì²˜ë¦¬
            } else {
                Log.e(TAG, "Response body is null")
            }
        } else {
            // ì˜¤ë¥˜ ì‘ë‹µ ì²˜ë¦¬
            Log.e(TAG, "Error: ${response.code()} - ${response.message()}")
            // ì˜¤ë¥˜ ë³¸ë¬¸ íŒŒì‹± (response.errorBody()) ë“±
        }
    } catch (e: Exception) { // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë˜ëŠ” ê¸°íƒ€ ì˜ˆì™¸ ì²˜ë¦¬
        Log.e(TAG, "Network request failed", e)
        // ì‚¬ìš©ìì—ê²Œ ì˜¤ë¥˜ í‘œì‹œ ë“±
    }
}
```

### OkHttpë¥¼ ì‚¬ìš©í•œ ì»¤ìŠ¤í…€ HTTP ìš”ì²­

* ì§ì ‘ `Request`/`Call` êµ¬ì„±, `enqueue` ë¹„ë™ê¸° ì½œë°±ìœ¼ë¡œ ì‘ë‹µ ì²˜ë¦¬.
* `response.use {}`ë¡œ ìë™ close, `body.string()`ì€ 1íšŒë§Œ ì†Œë¹„ ê°€ëŠ¥.
* UI ì—…ë°ì´íŠ¸ëŠ” ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ìˆ˜í–‰(ì˜ˆ: `runOnUiThread`).

```kotlin
val client = OkHttpClient()

val request = Request.Builder()
    .url("https://api.example.com/data")
    .build()

// ë¹„ë™ê¸° ìš”ì²­ ì‹¤í–‰
client.newCall(request).enqueue(object : Callback {
    override fun onFailure(call: Call, e: IOException) {
        // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì²˜ë¦¬
        e.printStackTrace()
    }

    override fun onResponse(call: Call, response: Response) {
        // ì‘ë‹µ ìŠ¤ë ˆë“œëŠ” ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ UI ì—…ë°ì´íŠ¸ ì‹œ ì£¼ì˜
        response.use { // response.body().close() ìë™ í˜¸ì¶œ
            if (response.isSuccessful) {
                val responseBody = response.body?.string() // ì‘ë‹µ ë³¸ë¬¸ ì½ê¸° (í•œ ë²ˆë§Œ ê°€ëŠ¥)
                Log.d(TAG, "Response: $responseBody")
                // UI ì—…ë°ì´íŠ¸ëŠ” ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ìˆ˜í–‰
                // runOnUiThread { /* UI ì—…ë°ì´íŠ¸ */ }
            } else {
                Log.e(TAG, "Error: ${response.code}")
            }
        }
    }
})
```

### OkHttpì™€ Retrofit í†µí•©í•˜ê¸°

* Retrofitì˜ HTTP í´ë¼ì´ì–¸íŠ¸ë¡œ **ì»¤ìŠ¤í…€ OkHttpClient** ì£¼ì….
* ì¸í„°ì…‰í„°ë¡œ ë¡œê¹…/ì¸ì¦ í† í° ìë™ ì²¨ë¶€, íƒ€ì„ì•„ì›ƒ ë“± ê³µí†µ ë„¤íŠ¸ì›Œí‚¹ ì •ì±… ì¤‘ì•™í™”.

```kotlin
val okHttpClient = OkHttpClient.Builder()
    // ë¡œê¹… ì¸í„°ì…‰í„° ì¶”ê°€ (ì˜ˆì‹œ)
    .addInterceptor(HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY })
    // ì¸ì¦ í—¤ë” ì¶”ê°€ ì¸í„°ì…‰í„°
    .addInterceptor { chain ->
        val originalRequest = chain.request()
        val newRequest = originalRequest.newBuilder()
            .header("Authorization", "Bearer your_token") // ì‹¤ì œ í† í° ì‚¬ìš©
            .build()
        chain.proceed(newRequest)
    }
    .connectTimeout(30, TimeUnit.SECONDS) // íƒ€ì„ì•„ì›ƒ ì„¤ì • (ì„ íƒ ì‚¬í•­)
    .readTimeout(30, TimeUnit.SECONDS)
    .build()

val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .client(okHttpClient) // ì»¤ìŠ¤í…€ OkHttpClient ì„¤ì •
    .addConverterFactory(GsonConverterFactory.create()) // ë˜ëŠ” ë‹¤ë¥¸ Converter Factory
    .build()
```

### ìš”ì•½

* **Retrofit**: ì„ ì–¸ì Â·íƒ€ì… ì„¸ì´í”„ API + ConverterFactory + ì½”ë£¨í‹´ìœ¼ë¡œ ê°œë°œ ìƒì‚°ì„±ê³¼ ì•ˆì •ì„± í–¥ìƒ.
* **OkHttp**: ì¸í„°ì…‰í„°Â·íƒ€ì„ì•„ì›ƒÂ·ìºì‹± ë“± ì „ì†¡ ê³„ì¸µ ì œì–´ë¡œ íš¨ìœ¨/ì‹ ë¢°ì„± í™•ë³´.
* **ì¡°í•© ì‚¬ìš©**: Retrofitì˜ ë‹¨ìˆœí•¨ + OkHttpì˜ ìœ ì—°ì„±ìœ¼ë¡œ ë¡œê¹…/ì¸ì¦/ì—ëŸ¬ ì²˜ë¦¬/íƒ€ì„ì•„ì›ƒì„ ì¼ê´€ ì ìš©í•˜ì—¬ ì‹¤ë¬´í˜• ë„¤íŠ¸ì›Œí‚¹ ê¸°ë°˜ì„ êµ¬ì¶•.


### ğŸ’¡ Pro Tips for Mastery: OkHttp Authenticator ë° Interceptorë¥¼ ì‚¬ìš©í•˜ì—¬ OAuth í† í° ê°±ì‹ í•˜ê¸°

* í•µì‹¬: OAuth í† í° ë§Œë£Œ ëŒ€ì‘ì—ëŠ” OkHttpì˜ [Authenticator](https://square.github.io/okhttp/3.x/okhttp/okhttp3/Authenticator.html)(401 ì‘ë‹µ ì‹œ ìë™ íŠ¸ë¦¬ê±°)ì™€ [Interceptor](https://square.github.io/okhttp/features/interceptors/)(ìš”ì²­/ì‘ë‹µì„ ì„ì˜ ë¡œì§ìœ¼ë¡œ ê°€ë¡œì±„ ì²˜ë¦¬) ë‘ ê°€ì§€ê°€ ìˆë‹¤.
* ì„ íƒ ê¸°ì¤€: ë‹¨ìˆœ â€œ401â†’í† í° ì¬ë°œê¸‰â†’ì¬ì‹œë„â€ëŠ” **Authenticator**, ìš”ì²­ ì „ í† í° ë¶€ì°©Â·íŠ¹ìˆ˜ ì¬ì‹œë„ ê·œì¹™ ë“± ì„¸ë°€ ì œì–´ëŠ” **Interceptor**ê°€ ì í•©.

#### OkHttp Authenticator

* 401 Unauthorized ì‘ë‹µ ì‹œ ìë™ í˜¸ì¶œë˜ì–´ **ìƒˆ í† í°ìœ¼ë¡œ ì¬ìš”ì²­**ì„ ìƒì„±.
* ë™ê¸° ê°±ì‹ ì„ í•œ ë²ˆë§Œ ì‹œë„í•˜ê³ , ì‹¤íŒ¨ ì‹œ null ë°˜í™˜í•˜ì—¬ ë£¨í”„/ë¶ˆí•„ìš” ì¬ì‹œë„ ë°©ì§€.
* ì‚¬ìš©ë²•: `OkHttpClient.Builder.authenticator(...)`ë¡œ ë“±ë¡.

```kotlin
class TokenAuthenticator(
    private val tokenProvider: TokenProvider // í† í° ì œê³µ ë° ìƒˆë¡œê³ ì¹¨ ë¡œì§ ìº¡ìŠí™”
) : Authenticator {

    override fun authenticate(route: Route?, response: Response): Request? {
        // ì´ì „ ìš”ì²­ì´ ì´ë¯¸ ì¸ì¦ í—¤ë”ë¥¼ ê°€ì§€ê³  ìˆì—ˆëŠ”ì§€ í™•ì¸ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
        val previousToken = response.request.header("Authorization")

        // í† í° ë™ê¸°í™” ë° ìƒˆë¡œê³ ì¹¨ (í•œ ë²ˆë§Œ ì‹œë„í•˜ë„ë¡ ì œì–´)
        synchronized(this) {
            // í˜„ì¬ í† í°ê³¼ ì´ì „ ìš”ì²­ì˜ í† í° ë¹„êµ
            val currentToken = tokenProvider.getToken() // í˜„ì¬ ì €ì¥ëœ í† í° ê°€ì ¸ì˜¤ê¸°
            // í† í°ì´ ë³€ê²½ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨ ì‹œ null ë°˜í™˜ (ë” ì´ìƒ ì¬ì‹œë„ ì•ˆ í•¨)
            if (previousToken != null && previousToken == "Bearer $currentToken") {
                val newToken = tokenProvider.refreshToken() // ë™ê¸°ì ìœ¼ë¡œ í† í° ìƒˆë¡œê³ ì¹¨ ì‹œë„
                if (newToken == null) {
                    // ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨ ì‹œ ì²˜ë¦¬ (ì˜ˆ: ë¡œê·¸ì•„ì›ƒ)
                    tokenProvider.clearToken() // í† í° ì œê±°
                    return null // ì¸ì¦ ì‹¤íŒ¨
                }
            }

            // ìƒˆë¡œê³ ì¹¨ëœ í† í° ë˜ëŠ” í˜„ì¬ í† í°ìœ¼ë¡œ ìƒˆ ìš”ì²­ ìƒì„±
            val refreshedToken = tokenProvider.getToken()
            if (refreshedToken != null) {
                return response.request.newBuilder()
                    .header("Authorization", "Bearer $refreshedToken")
                    .build()
            }
        }
        return null // í† í° ì—†ìœ¼ë©´ ì¸ì¦ ë¶ˆê°€
    }
}

// TokenProvider ì¸í„°í˜ì´ìŠ¤/í´ë˜ìŠ¤ (ì˜ˆì‹œ)
interface TokenProvider {
    fun getToken(): String?
    fun refreshToken(): String? // ë™ê¸° ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ í•„ìš”
    fun clearToken()
    // ... (í† í° ì €ì¥/ê´€ë¦¬ ë¡œì§)
}
```

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .authenticator(TokenAuthenticator(tokenProvider))
    // ... ë‹¤ë¥¸ ì„¤ì • ...
    .build()
```

#### OkHttp Interceptor ì‚¬ìš©í•˜ê¸°

* ëª¨ë“  ìš”ì²­ì— **í˜„ì¬ í† í°ì„ ë¶€ì°©**í•˜ê³ , ì‘ë‹µì´ 401ì´ë©´ **ë™ê¸° ê°±ì‹  í›„ ì¬ì‹œë„**.
* `synchronized`ë¡œ ì¤‘ë³µ ê°±ì‹  ì°¨ë‹¨, ì´ì „ ì‘ë‹µì€ `close()`ë¡œ ëˆ„ìˆ˜ ë°©ì§€.
* ì‚¬ìš©ë²•: `OkHttpClient.Builder.addInterceptor(...)`ë¡œ ë“±ë¡.

```kotlin
class TokenInterceptor(
    private val tokenProvider: TokenProvider
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        // í˜„ì¬ í† í° ê°€ì ¸ì˜¤ê¸°
        val token = tokenProvider.getToken()
        // ìš”ì²­ì— í† í° ì¶”ê°€ (í† í°ì´ ìˆëŠ” ê²½ìš°)
        val originalRequest = chain.request()
        val requestWithToken = if (token != null) {
            originalRequest.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            originalRequest // í† í° ì—†ìœ¼ë©´ ì›ë³¸ request ì‚¬ìš©
        }

        // í† í° ìš”ì²­
        var response = chain.proceed(requestWithToken)

        // í† í° ë§Œë£Œ í™•ì¸ (401 ì‘ë‹µ)
        if (response.code == 401) {
            // ë™ê¸°í™” ë¸”ë¡ìœ¼ë¡œ í† í° ìƒˆë¡œê³ ì¹¨ ì¤‘ë³µ ë°©ì§€
            synchronized(this) {
                val newToken = tokenProvider.refreshToken() // ë™ê¸°ì ìœ¼ë¡œ í† í° ìƒˆë¡œê³ ì¹¨
                if (newToken != null) {
                    // ìƒˆ í† í°ìœ¼ë¡œ request ë‹¤ì‹œ ë§Œë“¤ê¸°
                    val newRequest = requestWithToken.newBuilder()
                        .header("Authorization", "Bearer $newToken")
                        .build()
                    // ì´ì „ ì‘ë‹µ ë‹«ê¸° (ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ë°©ì§€)
                    response.close()
                    // ìƒˆë¡­ê²Œ ë§Œë“¤ì–´ì§„ requestë¡œ ì¬ì‹œë„
                    response = chain.proceed(newRequest)
                } else {
                    // ê°±ì‹  ì‹¤íŒ¨ ì‹œ ì²˜ë¦¬ (ë¡œê·¸ì•„ì›ƒ ë“±)
                    tokenProvider.clearToken()
                }
            }
        }
        return response
    }
}
```

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(TokenInterceptor(tokenProvider))
    // ... ë‹¤ë¥¸ ì„¤ì • ...
    .build()
```

#### Authenticatorì™€ Interceptorì˜ ì£¼ìš” ì°¨ì´ì 

* **ëª©ì **: AuthenticatorëŠ” ì¸ì¦ ì‹¤íŒ¨(401) ì „ìš©, InterceptorëŠ” ìš”ì²­/ì‘ë‹µ ì „/í›„ ì „ë°˜ ì œì–´.
* **íŠ¸ë¦¬ê±°**: AuthenticatorëŠ” 401ì—ì„œ **ìë™ í˜¸ì¶œ**, InterceptorëŠ” **ì§ì ‘ ê°ì§€/ì²˜ë¦¬ ë¡œì§** í•„ìš”.
* **ì‚¬ë¡€**: ë‹¨ìˆœ í† í° ì¬ë°œê¸‰ì€ Authenticator, ë³µì¡í•œ ì •ì±…(ì»¤ìŠ¤í…€ ì¬ì‹œë„Â·í—¤ë” ì£¼ì…Â·ë¡œê¹… ë³‘í–‰ ë“±)ì€ Interceptor.

#### ìš”ì•½

* **ë‹¨ìˆœ 401â†’ê°±ì‹ â†’ì¬ì‹œë„**: Authenticatorê°€ ê°€ì¥ ê°„ê²°í•˜ê³  ì•ˆì „.
* **ì„¸ë°€í•œ ì œì–´/ì»¤ìŠ¤í…€ íë¦„**: Interceptorë¡œ ìš”ì²­ ì „ í† í° ì£¼ì… + 401 ì‹œ ê°±ì‹ Â·ì¬ì‹œë„ êµ¬í˜„.
* ë‘ ë°©ì‹ ëª¨ë‘ ì‚¬ìš©ì ê²½í—˜ ì €í•˜ ì—†ì´ **íˆ¬ëª…í•œ í† í° ê°±ì‹ **ì„ ëª©í‘œë¡œ í•˜ë©°, ì•± ìš”êµ¬ì‚¬í•­ì˜ ë³µì¡ë„ì— ë”°ë¼ ì„ íƒÂ·ë³‘í–‰ êµ¬ì„± ê°€ëŠ¥.

### ğŸ’¡ Pro Tips for Mastery: Retrofit CallAdapterë€?

* í•µì‹¬: Retrofitì˜ [CallAdapter](https://square.github.io/retrofit/2.x/retrofit/retrofit2/CallAdapter.html)ëŠ” **API ë©”ì„œë“œ ë°˜í™˜ íƒ€ì…ì„ ì»¤ìŠ¤í…€**(ì˜ˆ: LiveData, Flow, RxJava, ìì²´ íƒ€ì…)í•˜ë„ë¡ í•´ì£¼ëŠ” ì¶”ìƒí™” ê³„ì¸µ.
* ì—­í• : ê¸°ë³¸ `Call<T>`ë¥¼ **ì›í•˜ëŠ” íƒ€ì…ìœ¼ë¡œ ë³€í™˜**í•´, ì½”ë£¨í‹´/ë°˜ì‘í˜• ë“± ë‹¤ì–‘í•œ íŒ¨ëŸ¬ë‹¤ì„ê³¼ Retrofitì„ **ë§¤ë„ëŸ½ê²Œ í†µí•©**.

#### CallAdapter ì‘ë™ ë°©ì‹

* Retrofitì´ ì¸í„°í˜ì´ìŠ¤ í”„ë¡ì‹œë¥¼ ë§Œë“¤ ë•Œ, `CallAdapter.Factory`ê°€ ë°˜í™˜ íƒ€ì…ì„ ë¶„ì„í•´ ì ì ˆí•œ `CallAdapter`ë¥¼ ì œê³µí•˜ê³ , ì–´ëŒ‘í„°ê°€ ëŸ°íƒ€ì„ì— `Call<T>` â†’ **ëª©í‘œ íƒ€ì…**ìœ¼ë¡œ ë³€í™˜.

#### Retrofitì˜ ê¸°ë³¸ CallAdapter

* ê¸°ë³¸ê°’ì€ `Call<T>` ê·¸ëŒ€ë¡œ ë°˜í™˜.
* ë‹¤ë¥¸ íƒ€ì…ì„ ì›í•˜ë©´ **ë¼ì´ë¸ŒëŸ¬ë¦¬ ì œê³µ ì–´ëŒ‘í„°**(ì˜ˆ: ì½”ë£¨í‹´) ì‚¬ìš© ë˜ëŠ” **ì§ì ‘ CallAdapter êµ¬í˜„** í•„ìš”.

#### Retrofitê³¼ Coroutine CallAdapter ì‚¬ìš©í•˜ê¸°

* Kotlinì—ì„  ì½”ë£¨í‹´ ì–´ëŒ‘í„°(ë‚´ì¥)ë¡œ `suspend` í•¨ìˆ˜ì—ì„œ **ê²°ê³¼/ì˜ˆì™¸ë¥¼ ì§ì ‘** ë‹¤ë£¸(ì¶”ê°€ ì„¤ì • ë¶ˆí•„ìš”).

```kotlin
interface ExampleApi {
    @GET("users")
    suspend fun getUsers(): List<User> // suspend í•¨ìˆ˜ë¡œ ì§ì ‘ ê²°ê³¼ ë°˜í™˜
}
```

* ë‚´ë¶€ì ìœ¼ë¡œëŠ” ì›ë˜ `Call<List<User>>`ë¥¼ ì½”ë£¨í‹´ `suspend` ì‹œê·¸ë‹ˆì²˜ë¡œ **ì–´ëŒ‘íŒ…**.

#### ì»¤ìŠ¤í…€ CallAdapter

* LiveData ë“± **íŠ¹ì • íƒ€ì…**ìœ¼ë¡œì˜ ë³€í™˜ì´ í•„ìš”í•˜ë©´ `CallAdapter`ì™€ `CallAdapter.Factory`ë¥¼ êµ¬í˜„í•´ ì—°ê²°.

```kotlin
import androidx.lifecycle.LiveData
import retrofit2.*
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type

// LiveDataë¥¼ ë°˜í™˜í•˜ëŠ” CallAdapter êµ¬í˜„
class LiveDataCallAdapter<R>(private val responseType: Type) : CallAdapter<R, LiveData<R>> {

    override fun responseType(): Type = responseType

    override fun adapt(call: Call<R>): LiveData<R> {
        return object : LiveData<R>() {
            private var started = AtomicBoolean(false)
            override fun onActive() {
                super.onActive()
                if (started.compareAndSet(false, true)) { // í•œ ë²ˆë§Œ ì‹¤í–‰ë˜ë„ë¡ ë³´ì¥
                    call.enqueue(object : Callback<R> {
                        override fun onResponse(call: Call<R>, response: Response<R>) {
                            postValue(response.body()) // postValue ì‚¬ìš© (ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ì‹¤í–‰ ê°€ëŠ¥ì„±)
                        }

                        override fun onFailure(call: Call<R>, t: Throwable) {
                            // ì˜¤ë¥˜ ì²˜ë¦¬: null ë˜ëŠ” íŠ¹ì • ì˜¤ë¥˜ ìƒíƒœ ì „ë‹¬
                            postValue(null)
                        }
                    })
                }
            }
        }
    }
}

// LiveDataCallAdapter ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” Factory
class LiveDataCallAdapterFactory : CallAdapter.Factory() {
    override fun get(
        returnType: Type,
        annotations: Array<Annotation>,
        retrofit: Retrofit
    ): CallAdapter<*, *>? {
        // ë°˜í™˜ íƒ€ì…ì´ LiveDataì¸ì§€ í™•ì¸
        if (getRawType(returnType) != LiveData::class.java) {
            return null
        }
        // LiveDataì˜ ì œë„¤ë¦­ íƒ€ì… ì¶”ì¶œ (LiveData<List<User>> ì—ì„œ List<User> ì¶”ì¶œ)
        val observableType = getParameterUpperBound(0, returnType as ParameterizedType)
        val rawObservableType = getRawType(observableType)
        // ì œë„¤ë¦­ íƒ€ì…ì´ Responseì¸ ê²½ìš° ì²˜ë¦¬ (ì„ íƒ ì‚¬í•­)
        if (rawObservableType == Response::class.java) {
            if (observableType !is ParameterizedType) {
                throw IllegalArgumentException("Response must be parameterized as Response<Foo> or Response<? extends Foo>")
            }
            val bodyType = getParameterUpperBound(0, observableType)
            return LiveDataCallAdapter<Any>(bodyType) // Response<T>ì˜ T íƒ€ì… ì‚¬ìš©
        }
        // ì¼ë°˜ LiveData<T> ë°˜í™˜ íƒ€ì… ì²˜ë¦¬
        return LiveDataCallAdapter<Any>(observableType)
    }
}
```

* Retrofitì— ë“±ë¡í•´ ì‚¬ìš©:

```kotlin
val retrofit = Retrofit.Builder()
    .baseUrl("https://example.com/")
    .addConverterFactory(GsonConverterFactory.create()) // Converter Factory ë¨¼ì € ì¶”ê°€
    .addCallAdapterFactory(LiveDataCallAdapterFactory()) // CallAdapter Factory ì¶”ê°€
    .build()
```

* API ì˜ˆì‹œ:

```kotlin
interface ExampleApi {
    @GET("users")
    fun getUsers(): LiveData<List<User>> // LiveData ë°˜í™˜ íƒ€ì…
}
```

#### ìš”ì•½

* **CallAdapter = ë°˜í™˜ íƒ€ì… ì‚¬ìš©ì ì •ì˜ ì–´ëŒ‘í„°**: `Call<T>` â†’ LiveData/Flow/Rx/ì»¤ìŠ¤í…€ ë“±ìœ¼ë¡œ ë³€í™˜í•´ **ì„ í˜¸í•˜ëŠ” ì•„í‚¤í…ì²˜ì™€ í†µí•©**.
* **ì½”ë£¨í‹´ì€ ê¸°ë³¸ ì§€ì›**: `suspend`ë¡œ ë°”ë¡œ ì‚¬ìš©.
* **íŠ¹ìˆ˜ ìš”êµ¬**(ìƒíƒœ ë˜í•‘, ì—ëŸ¬/ë¡œë”© ì¼ì²´ ì²˜ë¦¬ ë“±)ëŠ” **ì»¤ìŠ¤í…€ CallAdapter**ë¡œ ì„¸ë°€í•˜ê²Œ êµ¬í˜„.
* ë” ê¹Šì´ ë³´ê¸°: [Modeling Retrofit Responses With Sealed Classes and Coroutines](https://proandroiddev.com/modeling-retrofit-responses-with-sealed-classes-and-coroutines-9d6302077dfe).
