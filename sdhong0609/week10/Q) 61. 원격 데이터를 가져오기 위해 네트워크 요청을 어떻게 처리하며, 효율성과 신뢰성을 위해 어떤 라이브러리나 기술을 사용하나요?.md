## Q) 61. 원격 데이터를 가져오기 위해 네트워크 요청을 어떻게 처리하며, 효율성과 신뢰성을 위해 어떤 라이브러리나 기술을 사용하나요?

* 핵심: [Retrofit](https://square.github.io/retrofit/)은 선언적 API로 HTTP 호출을 단순화하고, [OkHttp](https://square.github.io/okhttp/)는 연결 풀링·캐싱·인터셉터로 전송 계층을 세밀 제어합니다.
* Retrofit은 ConverterFactory(Gson/Moshi/kotlinx.serialization)와 코루틴 `suspend`를 통해 타입 세이프·비동기 호출을 쉽게 합니다.
* OkHttp는 직접 요청/응답을 다루며, 콜백/인터셉터로 로깅·인증 헤더·타임아웃·캐싱 정책을 구성합니다.
* Retrofit 내부 클라이언트로 OkHttp를 사용하므로, **Retrofit + 커스텀 OkHttpClient** 조합으로 로깅/인증/타임아웃을 일관되게 적용할 수 있습니다.

### Retrofit을 사용한 네트워크 요청

* 선언적 인터페이스에 어노테이션으로 엔드포인트/HTTP 메서드 정의.
* ConverterFactory로 JSON ↔ 객체 변환, `viewModelScope` + `try/catch`로 성공/오류/예외 분기.
* `isSuccessful`·`body` null 체크 및 `errorBody` 파싱 등 기본 에러 처리 패턴 포함.

```kotlin
interface ApiService {
    @GET("data")
    // 코루틴 지원을 위한 suspend 함수 또는 Call<DataModel> 반환
    suspend fun fetchData(): Response<DataModel>
}
```

```kotlin
// Kotlinx Serialization Converter Factory 예시
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .addConverterFactory(Json{ ignoreUnknownKeys = true } // 알 수 없는 키 무시 설정 추가
        .asConverterFactory("application/json".toMediaType()))
    .build()

// API 서비스 인스턴스 생성
val apiService = retrofit.create(ApiService::class.java)
```

```kotlin
viewModelScope.launch { // ViewModel 스코프 또는 다른 코루틴 스코프 사용
    try {
        val response = apiService.fetchData()
        if (response.isSuccessful) {
            // 성공적인 응답 처리
            val data = response.body()
            if (data != null) {  // Nullable일 수 있으므로 확인 필요
                Log.d(TAG, "Data fetched: $it")
                 // UI 업데이트 또는 데이터 처리
            } else {
                Log.e(TAG, "Response body is null")
            }
        } else {
            // 오류 응답 처리
            Log.e(TAG, "Error: ${response.code()} - ${response.message()}")
            // 오류 본문 파싱 (response.errorBody()) 등
        }
    } catch (e: Exception) { // 네트워크 오류 또는 기타 예외 처리
        Log.e(TAG, "Network request failed", e)
        // 사용자에게 오류 표시 등
    }
}
```

### OkHttp를 사용한 커스텀 HTTP 요청

* 직접 `Request`/`Call` 구성, `enqueue` 비동기 콜백으로 응답 처리.
* `response.use {}`로 자동 close, `body.string()`은 1회만 소비 가능.
* UI 업데이트는 메인 스레드에서 수행(예: `runOnUiThread`).

```kotlin
val client = OkHttpClient()

val request = Request.Builder()
    .url("https://api.example.com/data")
    .build()

// 비동기 요청 실행
client.newCall(request).enqueue(object : Callback {
    override fun onFailure(call: Call, e: IOException) {
        // 네트워크 오류 처리
        e.printStackTrace()
    }

    override fun onResponse(call: Call, response: Response) {
        // 응답 스레드는 백그라운드 스레드일 수 있으므로 UI 업데이트 시 주의
        response.use { // response.body().close() 자동 호출
            if (response.isSuccessful) {
                val responseBody = response.body?.string() // 응답 본문 읽기 (한 번만 가능)
                Log.d(TAG, "Response: $responseBody")
                // UI 업데이트는 메인 스레드에서 수행
                // runOnUiThread { /* UI 업데이트 */ }
            } else {
                Log.e(TAG, "Error: ${response.code}")
            }
        }
    }
})
```

### OkHttp와 Retrofit 통합하기

* Retrofit의 HTTP 클라이언트로 **커스텀 OkHttpClient** 주입.
* 인터셉터로 로깅/인증 토큰 자동 첨부, 타임아웃 등 공통 네트워킹 정책 중앙화.

```kotlin
val okHttpClient = OkHttpClient.Builder()
    // 로깅 인터셉터 추가 (예시)
    .addInterceptor(HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY })
    // 인증 헤더 추가 인터셉터
    .addInterceptor { chain ->
        val originalRequest = chain.request()
        val newRequest = originalRequest.newBuilder()
            .header("Authorization", "Bearer your_token") // 실제 토큰 사용
            .build()
        chain.proceed(newRequest)
    }
    .connectTimeout(30, TimeUnit.SECONDS) // 타임아웃 설정 (선택 사항)
    .readTimeout(30, TimeUnit.SECONDS)
    .build()

val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com/")
    .client(okHttpClient) // 커스텀 OkHttpClient 설정
    .addConverterFactory(GsonConverterFactory.create()) // 또는 다른 Converter Factory
    .build()
```

### 요약

* **Retrofit**: 선언적·타입 세이프 API + ConverterFactory + 코루틴으로 개발 생산성과 안정성 향상.
* **OkHttp**: 인터셉터·타임아웃·캐싱 등 전송 계층 제어로 효율/신뢰성 확보.
* **조합 사용**: Retrofit의 단순함 + OkHttp의 유연성으로 로깅/인증/에러 처리/타임아웃을 일관 적용하여 실무형 네트워킹 기반을 구축.


### 💡 Pro Tips for Mastery: OkHttp Authenticator 및 Interceptor를 사용하여 OAuth 토큰 갱신하기

* 핵심: OAuth 토큰 만료 대응에는 OkHttp의 [Authenticator](https://square.github.io/okhttp/3.x/okhttp/okhttp3/Authenticator.html)(401 응답 시 자동 트리거)와 [Interceptor](https://square.github.io/okhttp/features/interceptors/)(요청/응답을 임의 로직으로 가로채 처리) 두 가지가 있다.
* 선택 기준: 단순 “401→토큰 재발급→재시도”는 **Authenticator**, 요청 전 토큰 부착·특수 재시도 규칙 등 세밀 제어는 **Interceptor**가 적합.

#### OkHttp Authenticator

* 401 Unauthorized 응답 시 자동 호출되어 **새 토큰으로 재요청**을 생성.
* 동기 갱신을 한 번만 시도하고, 실패 시 null 반환하여 루프/불필요 재시도 방지.
* 사용법: `OkHttpClient.Builder.authenticator(...)`로 등록.

```kotlin
class TokenAuthenticator(
    private val tokenProvider: TokenProvider // 토큰 제공 및 새로고침 로직 캡슐화
) : Authenticator {

    override fun authenticate(route: Route?, response: Response): Request? {
        // 이전 요청이 이미 인증 헤더를 가지고 있었는지 확인 (무한 루프 방지)
        val previousToken = response.request.header("Authorization")

        // 토큰 동기화 및 새로고침 (한 번만 시도하도록 제어)
        synchronized(this) {
            // 현재 토큰과 이전 요청의 토큰 비교
            val currentToken = tokenProvider.getToken() // 현재 저장된 토큰 가져오기
            // 토큰이 변경되지 않았거나 새로고침 실패 시 null 반환 (더 이상 재시도 안 함)
            if (previousToken != null && previousToken == "Bearer $currentToken") {
                val newToken = tokenProvider.refreshToken() // 동기적으로 토큰 새로고침 시도
                if (newToken == null) {
                    // 새로고침 실패 시 처리 (예: 로그아웃)
                    tokenProvider.clearToken() // 토큰 제거
                    return null // 인증 실패
                }
            }

            // 새로고침된 토큰 또는 현재 토큰으로 새 요청 생성
            val refreshedToken = tokenProvider.getToken()
            if (refreshedToken != null) {
                return response.request.newBuilder()
                    .header("Authorization", "Bearer $refreshedToken")
                    .build()
            }
        }
        return null // 토큰 없으면 인증 불가
    }
}

// TokenProvider 인터페이스/클래스 (예시)
interface TokenProvider {
    fun getToken(): String?
    fun refreshToken(): String? // 동기 방식으로 구현 필요
    fun clearToken()
    // ... (토큰 저장/관리 로직)
}
```

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .authenticator(TokenAuthenticator(tokenProvider))
    // ... 다른 설정 ...
    .build()
```

#### OkHttp Interceptor 사용하기

* 모든 요청에 **현재 토큰을 부착**하고, 응답이 401이면 **동기 갱신 후 재시도**.
* `synchronized`로 중복 갱신 차단, 이전 응답은 `close()`로 누수 방지.
* 사용법: `OkHttpClient.Builder.addInterceptor(...)`로 등록.

```kotlin
class TokenInterceptor(
    private val tokenProvider: TokenProvider
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        // 현재 토큰 가져오기
        val token = tokenProvider.getToken()
        // 요청에 토큰 추가 (토큰이 있는 경우)
        val originalRequest = chain.request()
        val requestWithToken = if (token != null) {
            originalRequest.newBuilder()
                .header("Authorization", "Bearer $token")
                .build()
        } else {
            originalRequest // 토큰 없으면 원본 request 사용
        }

        // 토큰 요청
        var response = chain.proceed(requestWithToken)

        // 토큰 만료 확인 (401 응답)
        if (response.code == 401) {
            // 동기화 블록으로 토큰 새로고침 중복 방지
            synchronized(this) {
                val newToken = tokenProvider.refreshToken() // 동기적으로 토큰 새로고침
                if (newToken != null) {
                    // 새 토큰으로 request 다시 만들기
                    val newRequest = requestWithToken.newBuilder()
                        .header("Authorization", "Bearer $newToken")
                        .build()
                    // 이전 응답 닫기 (리소스 누수 방지)
                    response.close()
                    // 새롭게 만들어진 request로 재시도
                    response = chain.proceed(newRequest)
                } else {
                    // 갱신 실패 시 처리 (로그아웃 등)
                    tokenProvider.clearToken()
                }
            }
        }
        return response
    }
}
```

```kotlin
val okHttpClient = OkHttpClient.Builder()
    .addInterceptor(TokenInterceptor(tokenProvider))
    // ... 다른 설정 ...
    .build()
```

#### Authenticator와 Interceptor의 주요 차이점

* **목적**: Authenticator는 인증 실패(401) 전용, Interceptor는 요청/응답 전/후 전반 제어.
* **트리거**: Authenticator는 401에서 **자동 호출**, Interceptor는 **직접 감지/처리 로직** 필요.
* **사례**: 단순 토큰 재발급은 Authenticator, 복잡한 정책(커스텀 재시도·헤더 주입·로깅 병행 등)은 Interceptor.

#### 요약

* **단순 401→갱신→재시도**: Authenticator가 가장 간결하고 안전.
* **세밀한 제어/커스텀 흐름**: Interceptor로 요청 전 토큰 주입 + 401 시 갱신·재시도 구현.
* 두 방식 모두 사용자 경험 저하 없이 **투명한 토큰 갱신**을 목표로 하며, 앱 요구사항의 복잡도에 따라 선택·병행 구성 가능.

### 💡 Pro Tips for Mastery: Retrofit CallAdapter란?

* 핵심: Retrofit의 [CallAdapter](https://square.github.io/retrofit/2.x/retrofit/retrofit2/CallAdapter.html)는 **API 메서드 반환 타입을 커스텀**(예: LiveData, Flow, RxJava, 자체 타입)하도록 해주는 추상화 계층.
* 역할: 기본 `Call<T>`를 **원하는 타입으로 변환**해, 코루틴/반응형 등 다양한 패러다임과 Retrofit을 **매끄럽게 통합**.

#### CallAdapter 작동 방식

* Retrofit이 인터페이스 프록시를 만들 때, `CallAdapter.Factory`가 반환 타입을 분석해 적절한 `CallAdapter`를 제공하고, 어댑터가 런타임에 `Call<T>` → **목표 타입**으로 변환.

#### Retrofit의 기본 CallAdapter

* 기본값은 `Call<T>` 그대로 반환.
* 다른 타입을 원하면 **라이브러리 제공 어댑터**(예: 코루틴) 사용 또는 **직접 CallAdapter 구현** 필요.

#### Retrofit과 Coroutine CallAdapter 사용하기

* Kotlin에선 코루틴 어댑터(내장)로 `suspend` 함수에서 **결과/예외를 직접** 다룸(추가 설정 불필요).

```kotlin
interface ExampleApi {
    @GET("users")
    suspend fun getUsers(): List<User> // suspend 함수로 직접 결과 반환
}
```

* 내부적으로는 원래 `Call<List<User>>`를 코루틴 `suspend` 시그니처로 **어댑팅**.

#### 커스텀 CallAdapter

* LiveData 등 **특정 타입**으로의 변환이 필요하면 `CallAdapter`와 `CallAdapter.Factory`를 구현해 연결.

```kotlin
import androidx.lifecycle.LiveData
import retrofit2.*
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type

// LiveData를 반환하는 CallAdapter 구현
class LiveDataCallAdapter<R>(private val responseType: Type) : CallAdapter<R, LiveData<R>> {

    override fun responseType(): Type = responseType

    override fun adapt(call: Call<R>): LiveData<R> {
        return object : LiveData<R>() {
            private var started = AtomicBoolean(false)
            override fun onActive() {
                super.onActive()
                if (started.compareAndSet(false, true)) { // 한 번만 실행되도록 보장
                    call.enqueue(object : Callback<R> {
                        override fun onResponse(call: Call<R>, response: Response<R>) {
                            postValue(response.body()) // postValue 사용 (백그라운드 스레드 실행 가능성)
                        }

                        override fun onFailure(call: Call<R>, t: Throwable) {
                            // 오류 처리: null 또는 특정 오류 상태 전달
                            postValue(null)
                        }
                    })
                }
            }
        }
    }
}

// LiveDataCallAdapter 인스턴스를 생성하는 Factory
class LiveDataCallAdapterFactory : CallAdapter.Factory() {
    override fun get(
        returnType: Type,
        annotations: Array<Annotation>,
        retrofit: Retrofit
    ): CallAdapter<*, *>? {
        // 반환 타입이 LiveData인지 확인
        if (getRawType(returnType) != LiveData::class.java) {
            return null
        }
        // LiveData의 제네릭 타입 추출 (LiveData<List<User>> 에서 List<User> 추출)
        val observableType = getParameterUpperBound(0, returnType as ParameterizedType)
        val rawObservableType = getRawType(observableType)
        // 제네릭 타입이 Response인 경우 처리 (선택 사항)
        if (rawObservableType == Response::class.java) {
            if (observableType !is ParameterizedType) {
                throw IllegalArgumentException("Response must be parameterized as Response<Foo> or Response<? extends Foo>")
            }
            val bodyType = getParameterUpperBound(0, observableType)
            return LiveDataCallAdapter<Any>(bodyType) // Response<T>의 T 타입 사용
        }
        // 일반 LiveData<T> 반환 타입 처리
        return LiveDataCallAdapter<Any>(observableType)
    }
}
```

* Retrofit에 등록해 사용:

```kotlin
val retrofit = Retrofit.Builder()
    .baseUrl("https://example.com/")
    .addConverterFactory(GsonConverterFactory.create()) // Converter Factory 먼저 추가
    .addCallAdapterFactory(LiveDataCallAdapterFactory()) // CallAdapter Factory 추가
    .build()
```

* API 예시:

```kotlin
interface ExampleApi {
    @GET("users")
    fun getUsers(): LiveData<List<User>> // LiveData 반환 타입
}
```

#### 요약

* **CallAdapter = 반환 타입 사용자 정의 어댑터**: `Call<T>` → LiveData/Flow/Rx/커스텀 등으로 변환해 **선호하는 아키텍처와 통합**.
* **코루틴은 기본 지원**: `suspend`로 바로 사용.
* **특수 요구**(상태 래핑, 에러/로딩 일체 처리 등)는 **커스텀 CallAdapter**로 세밀하게 구현.
* 더 깊이 보기: [Modeling Retrofit Responses With Sealed Classes and Coroutines](https://proandroiddev.com/modeling-retrofit-responses-with-sealed-classes-and-coroutines-9d6302077dfe).
