## ❓ **Q) 48. 웹 페이지를 어떻게 렌더링하나요?**

---

### 📘 개념
- **WebView**는 앱 내부에서 웹 콘텐츠(HTML/CSS/JavaScript)를 직접 표시하고 상호작용할 수 있는 **미니 브라우저** 역할을 합니다.  
- 다양한 안드로이드 버전에서 **최신 WebView 기능을 안전하게 활용**하려면 AndroidX **WebKit** 라이브러리를 사용합니다.  

---

### 🔧 WebView 초기화하기

#### XML 레이아웃에 WebView 추가
```xml
<!-- activity_main.xml -->
<WebView
    android:id="@+id/webView"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

#### 코드로 생성하기
```kotlin
// 그림 123. WebView.kt
val webView = WebView(this)
setContentView(webView)
```

---

### 🌐 웹 페이지 로드하기
- 네트워크 접근이 필요한 경우 **AndroidManifest.xml**에 권한을 추가합니다.

```kotlin
// 그림 124. WebView.kt
val webView: WebView = findViewById(R.id.webView)
webView.loadUrl("https://www.example.com")
```

```xml
<!-- AndroidManifest.xml -->
<uses-permission android:name="android.permission.INTERNET" />
```

---

### ⚙️ JavaScript 활성화하기
- 웹 콘텐츠가 JS를 요구하는 경우 **WebSettings**로 활성화합니다.

```kotlin
// 그림 125. WebView.kt
val webSettings = webView.settings
webSettings.javaScriptEnabled = true
```

---

### 🧭 WebView 동작 커스텀하기

#### 페이지 내비게이션 가로채기
- 외부 브라우저로 나가지 않고 **WebView 내부에서 링크 이동을 처리**하려면 `WebViewClient`를 설정합니다.  
- **API 24 미만**과 **이상**에서 오버로드가 다릅니다.

```kotlin
// 그림 126. Navigation.kt
webView.webViewClient = object : WebViewClient() {
    // API 24 미만
    override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {
        url?.let { view?.loadUrl(it) }
        return true // WebView가 URL 로딩을 처리
    }

    // API 24 이상
    override fun shouldOverrideUrlLoading(
        view: WebView?, request: WebResourceRequest?
    ): Boolean {
        request?.url?.let { view?.loadUrl(it.toString()) }
        return true // 외부 브라우저로 나가지 않도록 내부 처리
    }
}
```

---

### ⬇️ 다운로드 처리하기
- WebView 내에서 발생하는 **파일 다운로드**는 `DownloadListener`로 받아서 **DownloadManager**에 위임할 수 있습니다.

```kotlin
// 그림 127. DownloadListener.kt
webView.setDownloadListener { url, userAgent, contentDisposition, mimeType, contentLength ->
    // 여기서 파일 다운로드 처리 (예: DownloadManager 사용)
    val request = DownloadManager.Request(Uri.parse(url))
    // ... (필요한 DownloadManager 설정) ...
    val downloadManager = getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
    downloadManager.enqueue(request)
}
```

---

### 🧪 WebView에서 JavaScript 실행하기
- `evaluateJavascript`(API 19+) 또는 `loadUrl("javascript:...")` 방식으로 **JS 주입/실행**이 가능합니다.

```kotlin
// 그림 128. JavaScript.kt
// 권장: API 19+
webView.evaluateJavascript(
    "document.body.style.backgroundColor = 'red';"
) { result ->
    Log.d("WebView", "JavaScript 실행 결과: $result")
}

// 이전 방식 (결과 콜백 X)
// webView.loadUrl("javascript:document.body.style.backgroundColor = 'blue';")
```

---

### 🔗 JavaScript ↔ 안드로이드 바인딩(개요)
- `addJavascriptInterface()`로 **Java/Kotlin 객체를 JS 컨텍스트에 노출**하여, JS에서 네이티브 기능(Toast, Dialog 등)을 호출할 수 있습니다.  
- (문서 예시: *그림 129. WebAppInterface.kt* — `@JavascriptInterface`로 메서드 노출)

---

### 🔒 보안 고려 사항
- 필요하지 않다면 **JavaScript 비활성화**를 유지하세요.  
- `setAllowFileAccess()`, `setAllowFileAccessFromFileURLs()` 사용은 신중히.  
- **XSS/URL 스푸핑 방지** 위해 입력 검증 및 URL 정제 필수.  
- `@JavascriptInterface`로 노출하는 메서드는 **표면적을 최소화**하고 검증/권한 체크를 적용하세요.

---

### 🧾 요약
- WebView는 앱 내에서 웹을 렌더링하는 기본 컴포넌트이며, `WebViewClient`로 내비게이션을 커스텀하고 필요 시 JavaScript를 활성화하여 사용자 경험을 조정할 수 있습니다.  
- 다만 **보안/성능 영향**을 항상 고려해야 합니다.

---

### 💬 실전 질문 (문서 원문)
**Q) 외부 링크를 클릭할 때 사용자가 앱을 벗어나는 것을 방지하기 위해  
WebView 내비게이션을 효과적으로 처리하는 방법에는 무엇이 있는지 설명해 주세요**

✅ **답변**  
1) **`WebViewClient` 지정**: `shouldOverrideUrlLoading`을 구현해 **모든 URL 로딩을 WebView 내부에서 처리**하도록 합니다.  
   - **API 24 미만**: `(view, url)` 오버로드에서 `view?.loadUrl(url)` 수행 후 `true` 반환.  
   - **API 24 이상**: `(view, request)` 오버로드에서 `request.url`을 `loadUrl()`로 처리 후 `true` 반환.  
2) **다운로드 링크 대응**: 파일 다운로드 링크는 `setDownloadListener`에서 받아 **DownloadManager**로 처리해 **외부 앱 호출을 방지**합니다.  
3) **에러/리다이렉트 대비**: 필요 시 `onPageStarted/onReceivedError` 등을 함께 구현해 **의도치 않은 외부 이동**이나 실패 케이스를 제어합니다.  
4) **보안 검증**: 이동 대상 **URL 화이트리스트/스킴 필터링**과 **HTTPS 강제**로 피싱/스푸핑을 예방합니다.

# 🌐 크로미움(WebView) vs Jetpack WebView(ANDROIDX WebKit) — 차이와 코드 예제

> 요약  
> - **크로미움 WebView** = 시스템에 내장된 `android.webkit.WebView` 렌더링 엔진.  
> - **Jetpack WebView(ANDROIDX WebKit)** = 같은 엔진을 쓰되, **`androidx.webkit.*` Compat API**로 **하위 호환 + 최신 기능 노출/토글**을 쉽게 해주는 **래퍼/확장 라이브러리**.  
> - 실무 포인트 = **기능 감지(`WebViewFeature`) + Compat 설정**로 버전별 분기를 최소화하고, 최신 기능(다크모드, 세이프브라우징, 서비스워커, 메시지 브리지 등)을 안정적으로 사용.

---

## 1) 시스템 크로미움 WebView (기본 엔진)
- **클래스**: `android.webkit.WebView`
- **업데이트 경로**: OS/Play 스토어의 *Android System WebView* 앱을 통해 엔진 업데이트
- **장점**: 모든 앱이 공통 엔진 사용 → 보안 패치/성능 개선이 일괄 반영
- **한계**: 새 기능/플래그의 **노출 타이밍이 기기/OS에 종속**, 버전별 분기 코드가 늘어남

### 기본 사용 예
```xml
<!-- activity_main.xml -->
<WebView
    android:id="@+id/webView"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />
```

```kotlin
// 기본 로드
val webView: WebView = findViewById(R.id.webView)
webView.settings.javaScriptEnabled = true
webView.loadUrl("https://www.example.com")
```

---

## 2) Jetpack WebView (ANDROIDX WebKit)
- **아티팩트**: `androidx.webkit:webkit:<version>`
- **핵심 아이디어**: 같은 시스템 WebView 엔진을 쓰지만, **Compat 계층**으로
  - 하위 OS에서도 **일관된 API 표면** 제공
  - **기능 지원 여부 감지**(`WebViewFeature.isFeatureSupported`)
  - **설정/동작을 Compat로 적용**(`WebSettingsCompat`, `WebViewCompat`, …)

### Gradle 추가
```kotlin
dependencies {
    implementation("androidx.webkit:webkit:1.11.0") // 예시 버전
}
```

---

## 3) 버전별/기능별 분기 — “엔진 기능 감지 → 안전하게 사용”
> 패턴: `WebViewFeature.isFeatureSupported(FEATURE)` → 지원 시 Compat API 호출

### (A) 다크 모드 강제(Force Dark)
```kotlin
val settings = webView.settings

if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK)) {
    // 시스템 다크모드 대응 강제
    WebSettingsCompat.setForceDark(
        settings,
        WebSettingsCompat.FORCE_DARK_ON
    )
}

// 다크 전략 (CSS/이미지 등 포함 변환)
if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK_STRATEGY)) {
    WebSettingsCompat.setForceDarkStrategy(
        settings,
        WebSettingsCompat.DARK_STRATEGY_WEB_THEME_DARKENING_ONLY
        // or DARK_STRATEGY_PREFER_WEB_THEME_OVER_USER_AGENT_DARKENING
    )
}
```

### (B) Safe Browsing (피싱/멀웨어 탐지)
```kotlin
if (WebViewFeature.isFeatureSupported(WebViewFeature.START_SAFE_BROWSING)) {
    WebViewCompat.startSafeBrowsing(this) { success ->
        // 초기화 성공/실패 로깅
    }
}

// 위협 감지시 콜백 (Compat)
webView.webViewClient = object : WebViewClientCompat() {
    override fun onSafeBrowsingHit(
        view: WebView,
        request: WebResourceRequest,
        threatType: Int,
        callback: SafeBrowsingResponseCompat
    ) {
        // 차단/계속 등 정책 결정
        callback.backToSafety(true) // 뒤로 이동 + 보고
        // callback.proceed(false)  // 계속 진행 (권장 X)
        // callback.showInterstitial(true)
    }
}
```

### (C) Service Worker (오프라인/프록싱/캐싱)
```kotlin
if (WebViewFeature.isFeatureSupported(WebViewFeature.SERVICE_WORKER_BASIC_USAGE)) {
    val controller = ServiceWorkerControllerCompat.getInstance()
    controller.setServiceWorkerClient(object : ServiceWorkerClientCompat() {
        override fun shouldInterceptRequest(request: WebResourceRequest): WebResourceResponse? {
            // 필요시 요청 가로채 캐시/프록시/로깅
            return null
        }
    })
}
```

### (D) WebMessage / JS ↔ 네이티브 양방향 메시지 (postMessage)
- 최신 스펙 기반 메시징. `addWebMessageListener` 지원 시 **도메인 화이트리스트** 기반으로 안전하게 브리징.
```kotlin
if (WebViewFeature.isFeatureSupported(WebViewFeature.WEB_MESSAGE_LISTENER)) {
    WebViewCompat.addWebMessageListener(
        webView,
        "AndroidBridge",                    // JS에서 노출되는 객체명
        setOf("https://www.example.com"),   // 허용 오리진(필수)
        object : WebViewCompat.WebMessageListener {
            override fun onPostMessage(
                view: WebView,
                message: WebMessageCompat,
                sourceOrigin: Uri,
                isMainFrame: Boolean,
                replyProxy: JavaScriptReplyProxy
            ) {
                // JS → 앱 메시지 수신
                val payload = message.data
                Log.d("Bridge", "from JS: $payload @ $sourceOrigin (main:$isMainFrame)")
                replyProxy.postMessage("Ack: $payload") // 앱 → JS 응답
            }
        }
    )
}
```

### (E) 안전한 로컬 리소스 제공 — `WebViewAssetLoader`
- 앱 번들/내부 저장 파일을 **HTTPS처럼 안전한 가짜 도메인**으로 매핑해 로드
```kotlin
val assetLoader = WebViewAssetLoader.Builder()
    .addPathHandler("/assets/", WebViewAssetLoader.AssetsPathHandler(this))
    .addPathHandler("/res/",    WebViewAssetLoader.ResourcesPathHandler(this))
    .build()

webView.webViewClient = object : WebViewClientCompat() {
    override fun shouldInterceptRequest(
        view: WebView,
        request: WebResourceRequest
    ): WebResourceResponse? {
        return assetLoader.shouldInterceptRequest(request.url)
    }
}

// 예: https://appassets.androidplatform.net/assets/www/index.html
webView.loadUrl("https://appassets.androidplatform.net/assets/www/index.html")
```

---

## 4) 외부 링크 “앱 이탈 방지” 내비게이션 처리 (실전 질문 대응)
> **목표**: 사용자가 링크를 눌러도 **항상 WebView 내부에서 처리**.  
> **전략**: `WebViewClient`에서 `shouldOverrideUrlLoading()` 구현 + **화이트리스트/스킴 필터**.

```kotlin
webView.webViewClient = object : WebViewClientCompat() {

    // API 24 미만 (Deprecated 시그니처에도 대비)
    override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {
        val safe = url?.takeIf(::isAllowedUrl) ?: return true
        view?.loadUrl(safe)
        return true // 외부 브라우저로 가지 않음
    }

    // API 24 이상
    override fun shouldOverrideUrlLoading(
        view: WebView,
        request: WebResourceRequest
    ): Boolean {
        val target = request.url.toString()
        if (!isAllowedUrl(target)) return true // 차단
        view.loadUrl(target)
        return true
    }

    override fun onReceivedError(
        view: WebView,
        request: WebResourceRequest,
        error: WebResourceErrorCompat
    ) {
        if (request.isForMainFrame) {
            // 에러 페이지/리트라이 UI
        }
    }
}

// 화이트리스트/스킴 필터(예시)
fun isAllowedUrl(url: String): Boolean {
    val uri = Uri.parse(url)
    val allowedHosts = setOf("www.example.com", "m.example.com")
    val allowedSchemes = setOf("https") // http 차단
    return uri.scheme in allowedSchemes && uri.host in allowedHosts
}
```

> 파일 다운로드까지 내부 처리하려면 `DownloadListener` + `DownloadManager`로 이어서 처리:
```kotlin
webView.setDownloadListener { url, ua, cd, mime, len ->
    val req = DownloadManager.Request(Uri.parse(url))
        .setNotificationVisibility(
            DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED
        )
    val dm = getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
    dm.enqueue(req)
}
```

---

## 5) 보안 팁 (필수 체크리스트)
- **JS 필요 시에만 활성화**: `javaScriptEnabled = true` 남발 금지  
- **도메인 화이트리스트**: 메시지 브리지/리디렉션/리소스 인터셉트 시 **허용 오리진** 명시  
- **HTTP 차단/HTTPS 강제**, Mixed Content 정책 확인  
- `addJavascriptInterface` 대신 가능하면 **`addWebMessageListener` + 오리진 제한** 선호  
- 파일 접근(`setAllowFileAccess*`)은 **최소 권한 원칙**  
- Safe Browsing 초기화 및 `onSafeBrowsingHit`에서 정책 명확화

---

## 6) 어떤 것을 쓰면 되나?
- **단순 표시/기본 기능**: 시스템 WebView만으로 충분  
- **버전 차이 없는 일관 API + 최신 기능 제어**: **Jetpack WebKit 권장**  
  - 예) 강제 다크모드, 서비스워커, 안전한 로컬 리소스 서빙, 메시지 브리지, 세이프브라우징 콜백 등

---

## 7) 빠른 스니펫 모음

### (1) 다크모드 한 줄 요약
```kotlin
if (WebViewFeature.isFeatureSupported(WebViewFeature.FORCE_DARK))
    WebSettingsCompat.setForceDark(webView.settings, WebSettingsCompat.FORCE_DARK_ON)
```

### (2) 메시지 브리지(JS↔앱)
```kotlin
if (WebViewFeature.isFeatureSupported(WebViewFeature.WEB_MESSAGE_LISTENER)) {
    WebViewCompat.addWebMessageListener(webView, "Bridge", setOf("https://site"), object : WebViewCompat.WebMessageListener {
        override fun onPostMessage(v: WebView, msg: WebMessageCompat, origin: Uri, isMain: Boolean, reply: JavaScriptReplyProxy) {
            reply.postMessage("pong")
        }
    })
}
```

### (3) 안전한 자산 서빙
```kotlin
val loader = WebViewAssetLoader.Builder()
    .addPathHandler("/assets/", WebViewAssetLoader.AssetsPathHandler(this))
    .build()

webView.webViewClient = object : WebViewClientCompat() {
    override fun shouldInterceptRequest(v: WebView, r: WebResourceRequest): WebResourceResponse? =
        loader.shouldInterceptRequest(r.url)
}
webView.loadUrl("https://appassets.androidplatform.net/assets/index.html")
```

---

## 결론
- **크로미움 WebView**는 “엔진”, **Jetpack WebKit**은 “엔진을 제어/확장하는 호환성 레이어”.  
- 실무에서는 **`WebViewFeature`로 지원여부를 감지**하고, **Compat API로 기능을 적용**하여 **버전 파편화**를 줄이세요.  
- 외부 링크/다운로드/보안은 **항상 화이트리스트와 정책**을 먼저 세우고 구현하세요.
