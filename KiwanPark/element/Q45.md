## ❓ Q) 45. 안드로이드의 Bitmap이란 무엇이며, 큰 Bitmap을 효율적으로 처리하는 방법은 무엇인가요?

---

### 📌 Bitmap 개요
- `Bitmap`은 픽셀 데이터를 메모리에 보관하는 **이미지 표현 객체**입니다. 해상도가 크면 메모리 사용량이 급증하여 성능 저하·크래시(OOM) 위험이 있습니다
- 카메라/네트워크 원본은 보통 **표시 요구 크기보다 훨씬 큼** → 그대로 로드하면 과도한 메모리, 성능 오버헤드, 크래시 위험이 커집니다

---

### 🧪 메모리 할당 없이 원본 크기 읽기 (`inJustDecodeBounds`)
- 먼저 이미지의 **가로·세로·MIME 타입만** 파악하여 “전체 로드가 필요한가?”를 판단합니다.  
- `BitmapFactory.Options.inJustDecodeBounds = true`로 설정하면 **픽셀 메모리 할당 없이** 메타데이터만 디코딩합니다

```kotlin
val options = BitmapFactory.Options().apply {
    inJustDecodeBounds = true
}
BitmapFactory.decodeResource(resources, R.drawable.myimage, options)

val imageWidth = options.outWidth
val imageHeight = options.outHeight
val imageType = options.outMimeType
```


---

### 🔎 샘플링을 사용하여 축소된 Bitmap 로드 (`inSampleSize`)
- 원본 크기를 파악했으면 **목표 크기(reqWidth/reqHeight)** 에 맞춰 **2의 배수로 서브샘플링**합니다.  
  예) `inSampleSize = 4`로 2048×1536 이미지를 로드하면 512×384 비트맵 생성

```kotlin
fun calculateInSampleSize(
    options: BitmapFactory.Options,
    reqWidth: Int,
    reqHeight: Int
): Int {
    val (height, width) = options.run { outHeight to outWidth }
    var inSampleSize = 1

    if (height > reqHeight || width > reqWidth) {
        val halfHeight = height / 2
        val halfWidth = width / 2

        // 요청 크기 이상이 될 때까지 2배씩 증가
        while (halfHeight / inSampleSize >= reqHeight &&
               halfWidth  / inSampleSize >= reqWidth) {
            inSampleSize *= 2
        }
    }
    return inSampleSize
}
```



---

### 🔁 서브샘플링을 사용한 **전체 디코딩 2단계 프로세스**
1) **경계만 디코딩**(`inJustDecodeBounds = true`)  
2) **계산된 `inSampleSize`로 실제 디코딩**  
이 순서로 필요한 해상도만 메모리에 올립니다

```kotlin
fun decodeSampledBitmapFromResource(
    res: Resources,
    resId: Int,
    reqWidth: Int,
    reqHeight: Int
): Bitmap? { // 실패 가능성 고려해 Bitmap? 반환
    return BitmapFactory.Options().run {
        // 1) 크기만 확인
        inJustDecodeBounds = true
        BitmapFactory.decodeResource(res, resId, this)

        // 2) 샘플링 비율 계산
        inSampleSize = calculateInSampleSize(this, reqWidth, reqHeight)

        // 3) 실제 디코딩
        inJustDecodeBounds = false
        BitmapFactory.decodeResource(res, resId, this)
    }
}
```


---

### 🖼️ 사용 예: `ImageView`에 최종 세팅
- `ImageView`의 목표 크기에 맞춰 디코딩한 후 바로 설정합니다

```kotlin
// ImageView 크기에 맞게 reqWidth, reqHeight 지정
val bitmap = decodeSampledBitmapFromResource(
    resources, R.drawable.myimage, 100, 100
)
imageView.setImageBitmap(bitmap)
```


---

### ✅ 요약
- **핵심 절차**: 크기만 확인 → `inSampleSize` 계산 → 축소 디코딩 → `ImageView`에 적용.  
- 이 2단계 샘플링 전략은 **메모리·성능 이슈를 예방**하고, 제한된 메모리 환경에서도 **안정적**으로 대용량 이미지를 처리하게 해줍니다

---

### 🧪 실전 질문
**Q) 큰 Bitmap을 메모리에 로드하는 것은 어떤 위험성이 있으며, 어떻게 효율적으로 처리할 수 있나요?**

**A)**
위험성은 **과도한 메모리 사용·성능 저하·크래시(OOM)** 입니다.  
대응은 위의 **서브샘플링 2단계 프로세스**를 따르며, 먼저 `inJustDecodeBounds`로 크기를 파악하고 `inSampleSize`를 계산하여 **필요한 해상도만 로드**합니다

---

### 💡 Pro Tips for Mastery: 큰 비트맵 캐싱 전략

#### A. LruCache를 사용한 메모리 내 캐싱
- 최근 사용 항목을 강한 참조로 보관하고, 덜 사용된 항목을 자동 제거하는 **LRU 정책**.
- 일반적으로 **가용 메모리의 1/8** 정도를 캐시로 할당(앱 성격에 맞춰 조정).

```kotlin
object LruCacheManager {
    // 사용 가능한 최대 메모리를 KB 단위로
    private val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
    // 캐시 크기를 최대 메모리의 1/8로 설정
    private val cacheSize = maxMemory / 8

    val memoryCache = object : LruCache<String, Bitmap>(cacheSize) {
        override fun sizeOf(key: String, value: Bitmap): Int {
            // 항목 크기를 KB로 계산
            return value.byteCount / 1024
        }
    }
}

// 사용 예시: 캐시 조회 → 없으면 플레이스홀더 & 백그라운드 디코딩 요청
fun loadBitmap(imageId: Int, imageView: ImageView, context: Context) {
    val key = imageId.toString()
    LruCacheManager.memoryCache.get(key)?.let { cached ->
        imageView.setImageBitmap(cached)
    } ?: run {
        imageView.setImageResource(R.drawable.image_placeholder)
        val work = OneTimeWorkRequestBuilder<BitmapDecodeWorker>()
            .setInputData(workDataOf("imageId" to imageId))
            .build()
        WorkManager.getInstance(context).enqueue(work)
    }
}
```

- **주의**: 캐시 값에 `SoftReference`/`WeakReference`를 쓰면 GC 상황에서 예측 불가하게 사라져 **캐시 일관성**이 떨어질 수 있어 권장되지 않습니다.

#### B. DiskLruCache를 사용한 디스크 기반 캐싱
- 앱 세션을 넘어 비트맵을 유지하고, **중복 디코딩/네트워크 재요청**을 줄입니다.
- 키 해싱(SHA-1 등)으로 안전한 파일명 생성, I/O 예외 처리, 중복 쓰기 방지 등 래퍼 클래스로 관리.

```kotlin
class DiskCacheManager(
    context: Context,
    cacheDirName: String = "images",
    cacheSize: Long = 10L * 1024 * 1024 // 10MB
) {
    private var diskLruCache: DiskLruCache? = null
    private val lock = Any()

    init {
        val dir = File(context.cacheDir, cacheDirName).apply { if (!exists()) mkdirs() }
        diskLruCache = DiskLruCache.open(dir, 1, 1, cacheSize)
    }

    private fun filenameForKey(key: String): String =
        try {
            val md = MessageDigest.getInstance("SHA-1")
            md.update(key.toByteArray())
            md.digest().joinToString("") { "%02x".format(it) }
        } catch (_: NoSuchAlgorithmException) {
            key.hashCode().toString() // fallback
        }

    fun get(key: String): Bitmap? = synchronized(lock) {
        val safe = filenameForKey(key)
        var snapshot: DiskLruCache.Snapshot? = null
        try {
            snapshot = diskLruCache?.get(safe)
            snapshot?.getInputStream(0)?.use { BitmapFactory.decodeStream(it) }
        } finally {
            snapshot?.close()
        }
    }

    fun set(key: String, bitmap: Bitmap) = synchronized(lock) {
        val safe = filenameForKey(key)
        var editor: DiskLruCache.Editor? = null
        try {
            editor = diskLruCache?.edit(safe)
            editor?.newOutputStream(0)?.use { os ->
                bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os)
                editor?.commit()
            } ?: diskLruCache?.flush()
        } catch (_: IOException) {
            try { editor?.abort() } catch (_: IOException) {}
        }
    }
}
```

#### C. WorkManager와 결합한 하이브리드 캐싱 플로우
- 메인 스레드 블로킹 없이 **백그라운드에서 디코딩 → 메모리/디스크 캐시에 저장**까지 자동화.

```kotlin
class BitmapDecodeWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    private val disk = DiskCacheManager(appContext)

    override suspend fun doWork(): Result {
        val key = inputData.getString("imageKey") ?: return Result.failure()
        val resId = inputData.getInt("imageId", -1).takeIf { it != -1 } ?: return Result.failure()

        // 1) 메모리 캐시
        LruCacheManager.memoryCache.get(key)?.let { return Result.success() }

        // 2) 디스크 캐시
        disk.get(key)?.let { fromDisk ->
            LruCacheManager.memoryCache.put(key, fromDisk)
            return Result.success()
        }

        // 3) 샘플링 디코딩
        val bmp = decodeSampledBitmapFromResource(
            applicationContext.resources, resId, reqWidth = 100, reqHeight = 100
        ) ?: return Result.failure()

        // 4) 캐시에 저장
        LruCacheManager.memoryCache.put(key, bmp)
        disk.set(key, bmp)
        return Result.success()
    }
}
```

---

### 🔄 Glide/Picasso 등 서드파티 라이브러리와의 비교

| 구분 | 커스텀(LruCache + DiskLruCache + WorkManager) | Glide / Picasso |
|---|---|---|
| 메모리 캐싱 | 수동 설계(크기 정책·LRU 한계 조정) | 자동 최적화·풀링·트랜스포메이션 고려 |
| 디스크 캐싱 | 직접 구현(키 해싱/I-O/동시성) | 내장 LRU 디스크 캐시, 자동 키 관리 |
| 스레딩/백프레셔 | WorkManager/Coroutine 직접 설계 | 자동 비동기 파이프라인, 요청 중복 제거 |
| 편의 기능 | 별도 구현 필요 | placeholder/error, thumbnail, transform 등 |
| 학습/유지비 | 높음(세밀 제어 가능) | 낮음(안정·생산성↑) |

**정리**  
- **커스텀 구현**: 프레임워크 수준 제어·특수 캐시 규칙·도메인 요구가 강할 때 적합.  
- **Glide/Picasso**: 대부분의 앱에서 **안정성·성능·개발 생산성**이 높아 기본 선택지로 권장. 필요 시 RequestOptions로 다운샘플·디코드 포맷·메모리 카테고리 등을 세밀 조정 가능합니다.

---

### ✅ 결론
1) **샘플링(서브샘플링) 2단계**로 필요한 해상도만 로드하고,  
2) **LruCache(메모리) + DiskLruCache(디스크)** 하이브리드로 재사용성을 극대화하며,  
3) **WorkManager**로 백그라운드 안전 처리,  
4) 일반적인 경우 **Glide** 같은 라이브러리로 검증된 파이프라인을 활용하는 것이 가장 실용적입니다.
